<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Getting Started</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="stylesheets/prism.css" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40269412-1']);
      _gaq.push(['_setDomainName', 'simit-lang.org']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index"><h1 class="title"> GraphIt</h1></a>
        <p>A high-performance graph domain specific language</p>
        <ul>
          <li><a href="http://github.com/yunmingzhang17/graphit">View On <strong>GitHub</strong></a></li>
        </ul>
	<p><a href="index">About</a></p>
        <p><a href="getting-started">Getting Started</a></p>
	<p><a href="python-getting-started">Python Binding Getting Started</a></p>
        <p><a href="language">Language Manual</a></p>
        <p><a href="publications">Publications</a></p>
	<p><a href="https://lists.csail.mit.edu/mailman/listinfo/graphit">Mailing List</a></p>
      </header>
      <footer>
        <p><a href="https://yunmingzhang.wordpress.com/">Yunming Zhang</a> <br>yunming at mit dot edu</p>
        <p><small>Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
      <section class="language-graphit">
      <h1 id="getting-started">Getting Started</h1>

<h2 id="downloading-software">Downloading software</h2>
<p>Make sure you have all the correct Open Source Software installed. First follow the <a href="https://github.com/yunmingzhang17/graphit">README</a> file here to clone and install graphIt. You will need either CILK or OPENMP to allow you to run the C++ code in parallel. If you dont have either you can get both by simply downloading <a href="https://gcc.gnu.org/">GCC</a>. Alternatively if you already have CILK or OPENMP you can use those too. This tutorial will go through how to use GraphIt via both CILK and OPENMP.</p>

<h2 id="cloning-graphit">Cloning graphit</h2>
<p>Clone graphit by going to <a href="https://github.com/yunmingzhang17/graphit">GraphIt</a>
        <em>Something to note for the following tutorial.</em>
        <em>Everything will be done graphit/build/bin</em></p>

<h2 id="basic-variables-constructs-and-functions">Basic Variables, Constructs, and Functions</h2>

<p>If you have not yet already please read the basic information on the <a href="language">GraphIt Language.</a></p>

<h3 id="pagerankdelta-example">PageRankDelta Example</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Vertex end
element Edge end
const edges : edgeset{Edge}(Vertex,Vertex) = load(argv[1]);
const vertices : vertexset{Vertex} = edges.getVertices();
const cur_rank : vector{Vertex}(float) = 0;
const ngh_sum : vector{Vertex}(float) = 0.0;
const delta : vector{Vertex}(float) = 1.0/vertices.size();
const out_degree : vector {Vertex}(int) = edges.getOutDegrees();
const damp : float = 0.85;
const beta_score : float = (1.0-damp)/vertices.size();
const epsilon2 : float = 0.1;
const epsilon : float = 0.0000001;

func updateEdge(src : Vertex, dst : Vertex)
    ngh_sum[dst] += delta[src]/out_degree[src];
end

func updateVertexFirstRound(v : Vertex) -&gt; output : bool
    delta[v] = damp*(ngh_sum[v]) + beta_score;
    cur_rank[v] += delta[v];
    delta[v] = delta[v]-1.0/vertices.size();
    output = (fabs(delta[v]) &gt; epsilon2*cur_rank[v]);
    ngh_sum[v] = 0;
end

func updateVertex(v : Vertex) -&gt; output : bool
   delta[v] = ngh_sum[v]*damp;
   cur_rank[v] += delta[v];
   ngh_sum[v] = 0;
   output = fabs(delta[v]) &gt; epsilon2*cur_rank[v];
end

func main()
    var n : int = edges.getVertices();
    var frontier : vertexset{Vertex} = new vertexset{Vertex}(n);
    for i in 1:10
        #s1# edges.from(frontier).apply(updateEdge);
        var output : vertexset{Vertex};
        if i == 1
           output = vertices.filter(updateVertexFirstRound);
        else
           output = vertices.filter(updateVertex);
        end
        delete frontier;
        frontier = output;
    end
    delete frontier;
end
</code></pre></div></div>

<p><em>Page Rank Delta in Graphit</em></p>

<p>Here we will go through an example of GraphIt Code using Page Rank Delta as an example. You can find a variant of this PagerankDelta file, along with a few other appliations, under your graphit/apps folder <a href="https://github.com/yunmingzhang17/graphit/tree/master/apps">here</a>.</p>

<p>Additionally here is a link to the <a href="https://dl.acm.org/citation.cfm?id=3276491">GraphIt OOPSLA18 paper</a> or <a href="https://arxiv.org/pdf/1805.00923.pdf">the arxiv report here</a>.  Sections 4 and 5 give the complete breakdown of the Page Rank Delta code. Please look here if you want a more detailed breakdown of the functionality of Graphit.</p>

<h3 id="algorithm-explanatation">Algorithm Explanatation</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Vertex end
element Edge end
</code></pre></div></div>

<p><em>element definitions</em></p>

<p>Here we construct the basic Elements, <code class="highlighter-rouge">Vertex</code> and <code class="highlighter-rouge">Edge</code> with the <code class="highlighter-rouge">element</code> keyword that will be used by graphit. Note these basic Elements do not have to be named ”Vertex” or “Edge”. Most Graph Algorithms will require that you have both of these. GraphIt supports multiple types of user-defined vertices and edges, which is important for algorithms that work on multiple graphs.</p>

<p><a href="http://graphit-lang.org/language#variables">A quick refresher on Variables</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Edge}(Vertex,Vertex) = load(argv[1]);
const vertices : vertexset{Vertex} = edges.getVertices();
</code></pre></div></div>

<p><em>vertexset and edgeset definitions</em></p>

<p>After defining element types, the programmer can construct vertexsets and edgesets. Lines 3–4 of Fig. 4 show the definitions of an edgeset, <code class="highlighter-rouge">edges</code>, and vertexset, <code class="highlighter-rouge">vertices</code>. Each element of the edgeset is of <code class="highlighter-rouge">Edge</code> type (specified between “{ }”), and the source and destination of the edge is of <code class="highlighter-rouge">Vertex</code> type (specified between “( )”). The edgeset declaration supports edges with different types of source and destination vertices (e.g., in a bipartite graph). vertices uses the <code class="highlighter-rouge">getVertices()</code> method on the edgeset, <code class="highlighter-rouge">edges</code>, to obtain the union of source and destination vertices of edges. The <code class="highlighter-rouge">const</code> keyword simply says this vertexset, edgeset, or vector is globally accessible.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const cur_rank : vector{Vertex}(float) = 0;
const ngh_sum : vector{Vertex}(float) = 0.0;
const delta : vector{Vertex}(float) = 1.0/vertices.size();
const out_degree : vector {Vertex}(int) = edges.getOutDegrees();
</code></pre></div></div>
<p><em>vector definitions</em></p>

<p>Data for vertices and edges are defined as vectors associated with an element type denoted using the { } syntax. For example, <code class="highlighter-rouge">cur_rank</code> is associated with <code class="highlighter-rouge">Vertex</code>, and is of type <code class="highlighter-rouge">float</code> (specified in the ( ) parenthesis). This is similar to fields of a struct in C or C++, but is stored as a separate vector.</p>

<p>When using <code class="highlighter-rouge">export</code> functions, the edgesets, vertexsets, vectors would need to be explicitly allocated by the user, as documented <a href="language#export-functions">here</a>.</p>

<p><img src="gallery/PageRankDeltaFuncs.png" alt="Page Rank Delta Code lines 12-27" /></p>

<p><em>Page Rank Delta Code lines 12-27</em></p>

<p><a href="http://graphit-lang.org/language#functions">A quick refresher on Functions</a></p>

<p>The algorithm described here uses 3 main functions.</p>

<p>The first is updateEdge which takes in an edge and adds to the current DeltaSum of the destination, the Delta of the source divided by the amount of out degrees of the source.</p>

<p>The second function is updateVertexFirstRound that takes in a vertex and returning a boolean. It does this by multiplying the deltasum generated by the function above with the damping factor and adding the basescore. From this it computes the rank and using the delta it computes whether or not it exceeds a certain threshold. If this threshold is exceeded than it returns a boolean True and if not a boolean False. Then it sets the DeltaSum back to 0.</p>

<p>The last function does something similar to above by taking in a vertex and returning a boolean. However in this case it does not add the base score to the deltaSum times damping factor when determining Delta. Similarly then by comparing if the delta exceeded the threshold of epilson times the rank it outputs a True or False.</p>

<p>The second and last functions will be used later on to filter out the “active vertices”. These are the vertices that will used in the next iteration of the algorithm. These active vertices are also known as the frontier. The reason for two functions is that the first time we update the vertexs some additional computation needs to be done as described above that isnt needed later on. Therefore the second function is run only once in the beginning of the algorithm.</p>

<p><img src="gallery/PageRankDeltaMain.png" alt="Page Rank Delta Code lines 28-39" /></p>

<p><em>Page Rank Delta Code lines 28-39</em></p>

<p>This is where your program comes together and runs together with all the functions you created. What makes GraphIt great is that the language constructs of GraphIt separates edge processing logic from edge traversal, edge filtering (from, to, srcFilter, and dstFilter), atomic synchronization, and modified vertex deduplication and tracking logic (apply and applyModified). This separation enables the compiler to represent the algorithm from a high level, exposing opportunities for edge traversal and vertex data layout optimizations. Moreover, it frees the programmer from specifying low-level implementation details, such as synchronization and deduplication logic.</p>

<p>The algorithm maintains the set of vertices whose rank has changed greatly from previous iterations. This list of vertices is generated by the vertices.filter in lines 33 to 36. These vertices are known as the Frontier. We start with having all vertices in the frontier(line 29-30). On each iteration we update all the deltasums using the updateEdge function. We use the operator from to obtain the set of edges that we want to operate on. Then we use apply to use a function on them.</p>

<p>As you can see in line 32 for all the edges that exist in the frontier we apply updateEdge. Then we generate a new set of vertices that are in the frontier. What Graphit allows us to do is create seperate functions for each part of the algorithm. In this case we have 2 general functions. One that updates the DeltaSum on each vertex and 2 that both determine if a Vertex should be in the Frontier. Then with graphit we can go in and optimize these specific parts functions without actually changing the code. All we need to do is change things in the scheduler. In this example we can modify #s1# and make the program run in parallel.</p>

<h3 id="scheduling-explanatation">Scheduling Explanatation</h3>

<p><img src="gallery/PageRankDeltaSchedule.png" alt="Page Rank Delta Schedule" /></p>

<p><em>Page Rank Delta Code Schedule</em></p>

<p>We use labels (#label#) in algorithm specifications to identify the statements on which optimizations apply. Programmers can assign a label on the left side of a statement and later reference it in the scheduling language. Above shows a simple schedule for the PageRankDelta implementation. The programmer adds label s1 to the edgeset operation statement. After the schedule keyword, the programmer can make a series of calls with the scheduling functions.</p>

<h2 id="tuning">Tuning</h2>

<p>We designed GraphIt’s scheduling language functions to allow programmers to compose together edge traversal direction, frontier data structure, parallelization, cache optimizations, and NUMA optimizations discussed in the <a href="https://arxiv.org/pdf/1805.00923.pdf">paper</a>. The configApplyDirection functions allow programmers to configure directions used for traversal. The programmer can use the configDenseVertexSet function to switch between bitvector and boolean array for either source or destination vertexset or both. The flexible configApplyNumSSG function configures the number of segmented subgraphs and how the subgraphs are partitioned (fixedvertex-count and edge-aware-vertex-count).</p>

<p>To compose together different optimizations, the programmer first chooses a direction for traversal. Then the programmer can use the other scheduling functions to pick one option for the parallelization, graph partitioning, NUMA, and dense vertexset optimizations for the current direction. The programmer can configure each direction separately using the optional direction argument for hybrid directions (DensePush-SparsePush or DensePull-SparsePush). If no direction argument is specified, then the configuration applies to both directions.</p>

<p>Here is a list of Scheduling functions that you can use</p>

<p><img src="gallery/SchedulingApply.png" alt="Scheduling Functions" /></p>

<p>Below we will show how changing the Schedule affects the C++ generated Code. This first section of psuedo code is pageRankDelta code without a schedule.</p>

<p><img src="gallery/pageRankDeltaGeneratedCodeDefault.png" alt="Page Rank Delta C++ Generated Code" /></p>

<p><em>This is the generated code for Page Rank Delta with no scheduling. This means that there are no optimizations. All this C++ code does is the basic page rank deltasum addition</em></p>

<p><img src="gallery/pageRankDeltaGeneratedCodeDensePull.png" alt="Page Rank Delta C++ Generated Code" /></p>

<p><em>With this Schedule program-&gt;configApplyDirection(“s1”, DensePull-SparsePush) the program is affecting the #s1# label associated with the code</em>
‘’’
edges.from(frontier).apply(updateEdge)
‘’’
<em>If the amount of edges exceeds a certain threshold then the program runs from destination to source. If it is under than it runs from source to destination. Depending on the density of the graph one option may run faster than the other.</em></p>

<p><img src="gallery/pageRankDeltaGeneratedCodeDynamic.png" alt="Page Rank Delta C++ Generated Code" /></p>

<p><em>Here by adding to the schedule the generated C++ is capable of running in parallel on multiple cores at once. This is seen by the parallel_for loop in the code and if that loop is run using CILK or OPENMV then it being run on mulitple cores will make the program much faster.</em></p>

<p><img src="gallery/pageRankDeltaGeneratedCodeBitVector.png" alt="Page Rank Delta C++ Generated Code" /></p>

<p><em>Adding this to the schedule will fuse vertexs together allowing them to be handled in groups. By doing this you will improve spatial locatility and this will improve your cache hit rate. However on the other hand this is require more processing. Thus depending on your algorithm using a bitvector may or may not be useful.</em></p>

<h2 id="compiling">Compiling</h2>

<p>Before we can compile Graphit you need to first follow these steps and build the bin for the program</p>

<h3 id="build-graphit">Build Graphit</h3>

<p>To perform an out-of-tree build of Graphit do:</p>

<p>After you have cloned the directory:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                cd graphit
                mkdir build
                cd build
                cmake ..
                make
</code></pre></div></div>
<p>To run the C++ test suite do (all tests should pass):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                cd build/bin
                ./graphit_test
</code></pre></div></div>
<p>To run the Python end-to-end test suite:</p>

<p>start at the top level graphit directory cloned from Github, NOT the build directory
(All tests would pass, but some would generate error messages from the g++ compiler. This is expected.)
Currently the project supports Python 2.x and not Python 3.x (the print syntax is different)</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                cd graphit/test/python
                python test.py
                python test_with_schedules.py
</code></pre></div></div>

<h3 id="compile-graphit-programs">Compile GraphIt Programs</h3>

<p><strong>For now all builds and compilations must be done in the graphit/build/bin directory due to linking and paths in the code. This will soon be updated so that users can compile anywhere but for now please do it in the bin.</strong></p>

<p>The graphit/build/bin is the location that cmake generates its binary files which are the actual executables for you to run your code. This is why to run any code you need to do it in the bin directory because that is where all the needed files are.</p>

<p>GraphIt compiler currently generates a C++ output file from the .gt input GraphIt programs. 
To compile an input GraphIt file with schedules in the same file (assuming the build directory is in the root project directory) do the following. The -f denotes the input file and the -o denotes the output file.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd build/bin
    python graphitc.py -f (input file path) -o (output file name)
    
</code></pre></div></div>

<p>The following is an example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd build/bin
    python graphitc.py -f ../../test/input/simple_vector_sum.gt -o test.cpp
    
</code></pre></div></div>

<p>To compile an input algorithm file and another separate schedule file (some of the test files have hardcoded paths to test inputs, be sure to modify that or change the directory you run the compiled files) do the following. -a in this case denotes a seperate algorithm.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd build/bin
    python graphitc.py -a (algorithm file path) -f (schedule file path) -o (output file name)
</code></pre></div></div>

<p>The example below compiles the algorithm file (../../test/input/cc.gt), with a separate schedule file (../../test/input_with_schedules/cc_pull_parallel.gt)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd build/bin
    python graphitc.py -a ../../test/input/cc.gt -f ../../test/input_with_schedules/cc_pull_parallel.gt -o test.cpp
</code></pre></div></div>

<p>All new files will be located inside the bin directory. You must make the files here but they can be run elsewhere. After you compile your C++ program you can insert it into your own program.</p>

<h3 id="compiling-and-using-graphit">Compiling and Using GraphIt</h3>

<p>To compile a serial version, you can use reguar g++ with support of c++11 standard to compile the generated C++ file (assuming it is named test.cpp).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # assuming you are still in the bin directory under build/bin. If not, just do cd build/bin from the root of the directory
    g++ -std=c++11 -I ../../src/runtime_lib/ test.cpp  -O3 -o test.o
    ./test.o
</code></pre></div></div>

<p>To compile a parallel version of the c++ program, you will need both CILK and OPENMP. OPENMP is required for programs using NUMA optimized schedule (configApplyNUMA enabled) and static parallel optimizations (static-vertex-parallel option in configApplyParallelization). All other programs can be compiled with CILK. For analyzing large graphs (e.g., twitter, friendster, webgraph) on NUMA machines, numacl -i all improves the parallel performance. For smaller graphs, such as LiveJournal and Road graphs, not using numactl can be faster.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # assuming you are still in the bin directory under build/bin. If not, just do cd build/bin from the root of the directory

    # compile and run with CILK
    icpc -std=c++11 -I ../../src/runtime_lib/ -DCILK test.cpp -O3 -o  test.o
    numactl -i all ./test.o
    
    # compile and run with OPENMP
    icpc -std=c++11 -I ../../src/runtime_lib/ -DOPENMP -qopenmp test.cpp -O3 -o test.o
    numactl -i all ./test.o
    
    # to run with NUMA optimizations
    OMP_PLACES=sockets ./test.o 
    
</code></pre></div></div>


      </section>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/prism.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-79370201-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
