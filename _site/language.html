<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>The Simit Programming Language</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="stylesheets/prism.css" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40269412-1']);
      _gaq.push(['_setDomainName', 'simit-lang.org']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index"><h1 class="title"> GraphIt</h1></a>
        <p>A high-performance graph domain specific language</p>
        <ul>
          <li><a href="http://github.com/simit-lang/simit">View On <strong>GitHub</strong></a></li>
          <li><a href="http://builds.simit-lang.org">Continuous<strong>Build Status</strong></a></li>
        </ul>
        <p><a href="getting-started">Getting Started</a></p>
        <p><a href="language">Language Manual</a></p>
        <p><a href="publications">Publications</a></p>
	<p><a href="user-group">User Group</a></p>
      </header>
      <footer>
        <p><a href="https://yunmingzhang.wordpress.com/">Yunming Zhang</a> <br>yunming at mit dot edu</p>
        <p><small>Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
      <section class="language-graphit">
      <h1 class="no_toc" id="the-simit-programming-language">The Simit Programming Language</h1>

<p>This guide introduces Simit language features and shows how they can be used in
programs. We assume that you are already familiar with imperative programming
and some linear algebra.</p>

<p>Simit is a linear algebra language with control flow. The main difference
between Simit and other linear algebra languages, such as Matlab and Julia, is
its <a href="#elements-sets-and-graphs">hypergraph data structure</a> that is used to
represent sparse systems, its <a href="#system-vectors-and-matrices">vector/matrix type
system</a> that ties them to the hypergraph, and the
<a href="#assemble-system-vectors-and-matrices">vector/matrix assembly</a> that lets you
assemble system vectors and matrices from hypergraphs.</p>

<ul id="markdown-toc">
  <li><a href="#basics" id="markdown-toc-basics">Basics</a>    <ul>
      <li><a href="#functions" id="markdown-toc-functions">Functions</a></li>
      <li><a href="#variables" id="markdown-toc-variables">Variables</a></li>
      <li><a href="#basic-types" id="markdown-toc-basic-types">Basic Types</a></li>
      <li><a href="#comments" id="markdown-toc-comments">Comments</a></li>
    </ul>
  </li>
  <li><a href="#control-flow-statements" id="markdown-toc-control-flow-statements">Control Flow Statements</a>    <ul>
      <li><a href="#if-statements" id="markdown-toc-if-statements">If Statements</a></li>
      <li><a href="#while-loops" id="markdown-toc-while-loops">While Loops</a></li>
      <li><a href="#do-while-loops" id="markdown-toc-do-while-loops">Do-While Loops</a></li>
      <li><a href="#for-loops" id="markdown-toc-for-loops">For Loops</a></li>
    </ul>
  </li>
  <li><a href="#vectors-and-matrices" id="markdown-toc-vectors-and-matrices">Vectors and Matrices</a>    <ul>
      <li><a href="#literals" id="markdown-toc-literals">Literals</a></li>
      <li><a href="#linear-algebra" id="markdown-toc-linear-algebra">Linear Algebra</a></li>
      <li><a href="#indexing" id="markdown-toc-indexing">Indexing</a></li>
      <li><a href="#slicing" id="markdown-toc-slicing">Slicing</a></li>
      <li><a href="#generic-range-dimensions" id="markdown-toc-generic-range-dimensions">Generic Range Dimensions</a></li>
    </ul>
  </li>
  <li><a href="#system-data-structures" id="markdown-toc-system-data-structures">System Data Structures</a>    <ul>
      <li><a href="#elements-sets-and-graphs" id="markdown-toc-elements-sets-and-graphs">Elements, Sets and Graphs</a>        <ul>
          <li><a href="#elements" id="markdown-toc-elements">Elements</a></li>
          <li><a href="#sets" id="markdown-toc-sets">Sets</a></li>
          <li><a href="#edge-sets" id="markdown-toc-edge-sets">Edge Sets</a></li>
          <li><a href="#grid-edge-sets" id="markdown-toc-grid-edge-sets">Grid Edge Sets</a></li>
        </ul>
      </li>
      <li><a href="#apply-stencil-update-functions" id="markdown-toc-apply-stencil-update-functions">Apply Stencil Update Functions</a></li>
      <li><a href="#system-vectors-and-matrices" id="markdown-toc-system-vectors-and-matrices">System Vectors and Matrices</a></li>
      <li><a href="#assemble-system-vectors-and-matrices" id="markdown-toc-assemble-system-vectors-and-matrices">Assemble System Vectors and Matrices</a></li>
      <li><a href="#coordinate-based-access" id="markdown-toc-coordinate-based-access">Coordinate-Based Access</a></li>
      <li><a href="#generic-set-dimensions" id="markdown-toc-generic-set-dimensions">Generic Set Dimensions</a></li>
    </ul>
  </li>
  <li><a href="#built-in-functions" id="markdown-toc-built-in-functions">Built-in Functions</a>    <ul>
      <li><a href="#scalar-math" id="markdown-toc-scalar-math">Scalar Math</a></li>
      <li><a href="#linear-algebra-1" id="markdown-toc-linear-algebra-1">Linear Algebra</a></li>
      <li><a href="#solvers" id="markdown-toc-solvers">Solvers</a></li>
      <li><a href="#complex-math" id="markdown-toc-complex-math">Complex Math</a></li>
    </ul>
  </li>
</ul>

<h1 id="basics">Basics</h1>
<p>Simit is an imperative language with statements, control flow and linear
algebra expressions. In this section, we describe some of the language’s basic
constructs.</p>

<h2 id="functions">Functions</h2>
<p>Functions can take any number of parameters, including none. Each parameter
must be declared with its name followed by its type (separated by a <code class="highlighter-rouge">:</code>). In
the following example, the function <code class="highlighter-rouge">add</code> takes two parameters named <code class="highlighter-rouge">a</code> and
<code class="highlighter-rouge">b</code>, both of which are of type <code class="highlighter-rouge">float</code>, and returns a single result (named <code class="highlighter-rouge">c</code>)
that is also a <code class="highlighter-rouge">float</code>. The function result is separated from the list of
parameters by a <code class="highlighter-rouge">-&gt;</code> and the function declaration is delimited by the <code class="highlighter-rouge">end</code>
keyword.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func add(a : float, b : float) -&gt; c : float
  c = a + b;
end
</code></pre></div></div>

<p>Like functions in MATLAB, Simit functions can return any number of results,
including none. In the next example, the function <code class="highlighter-rouge">minMax</code> takes two <code class="highlighter-rouge">float</code>
parameters and return two <code class="highlighter-rouge">float</code> results: the smaller of the two inputs as the
first result and the larger of the two inputs as the second result.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func minMax(a : float, b : float) 
    -&gt; (c : float, d : float)
  if a &lt; b
    c = a;
    d = b;
  else
    c = b;
    d = a;
  end
end
</code></pre></div></div>

<p>Note that the list of function results must be surrounded by parentheses if the
function returns more than one result. (The parentheses are optional if the
function returns just a single result.)</p>

<p>Exported functions can be called from C++ code through the <a href="api">Simit C++
API</a>. They are declared by prepending the function declaration with the
keyword <code class="highlighter-rouge">export</code>, as demonstrated below. Note that even though <code class="highlighter-rouge">main</code> does not
take any parameter, an (empty) parameter list must still be included in the
function declaration. Exported functions typically work on extern data
structures in global scope.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export func main()
  % Do something here
end
</code></pre></div></div>

<h2 id="variables">Variables</h2>
<p>Variables are declared in function bodies or in the global scope using the
<code class="highlighter-rouge">var</code> keyword. The following example declares an integer variable named <code class="highlighter-rouge">foo</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : int;
</code></pre></div></div>

<p>If the variable declaration has an initializer, then the variable’s type can be
inferred from the initializer value. The following are equivalent ways to
define a floating-point variable that is initialized to <code class="highlighter-rouge">0.0</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : float = 0.0;
var foo = 0.0;
</code></pre></div></div>

<p>The <code class="highlighter-rouge">const</code> keyword creates a variable that cannot be modified after
initialization.  The following example shows three ways to declare constant
variables that are initialized to <code class="highlighter-rouge">0.0</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const foo = 0.0;
const bar = foo;
bazz = 0.0;
</code></pre></div></div>

<p>Note that variables are const by default! That is, variables that are declared
without the <code class="highlighter-rouge">var</code> or <code class="highlighter-rouge">const</code> keywords are treated as const.</p>

<h2 id="basic-types">Basic Types</h2>
<p>Simit is statically typed with type inference. This means that the type of
every variable is known at compile time, but that you do not always have to
explicitly specify it; the compiler will figure most out automatically.</p>

<p>The basic numeric types in Simit are <code class="highlighter-rouge">bool</code>, <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">float</code> and <code class="highlighter-rouge">complex</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var mybool    : bool    = false;
var myint     : int     = 0;
var myfloat   : float   = 0.0;
var mycomplex : complex = &lt;0.0, 0.0&gt;;
</code></pre></div></div>

<p>The <code class="highlighter-rouge">float</code> and <code class="highlighter-rouge">complex</code> types are double-precision floating-point by default
when you use the CPU backend, but this can be changed to single-precision
floating-point when compiling a Simit program. The GPU backend currently only
supports single-precision floating-point <code class="highlighter-rouge">float</code> and <code class="highlighter-rouge">complex</code> types.</p>

<p>Simit also supports a <code class="highlighter-rouge">string</code> type that can be used for I/O and debugging. The
following example declares a variable containing the string “hello, world\n”:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var mystr : string = "hello, world\n";
</code></pre></div></div>

<h2 id="comments">Comments</h2>
<p>Single-line comments start with <code class="highlighter-rouge">%</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h = 0.01;  % h is the time-step size.
</code></pre></div></div>

<p>Multi-line comments are surrounded by <code class="highlighter-rouge">%{</code> and <code class="highlighter-rouge">%}</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%{
h is the time-step size.
h is initialized to one millisecond.
%}
h = 0.001;
</code></pre></div></div>

<h1 id="control-flow-statements">Control Flow Statements</h1>
<p>Simit supports a variety of control flow constructs, including <code class="highlighter-rouge">if</code> statements,
<code class="highlighter-rouge">while</code> loops, <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">while</code> loops and <code class="highlighter-rouge">for</code> loops.</p>

<h2 id="if-statements">If Statements</h2>

<p>In Simit, a simple <code class="highlighter-rouge">if</code> statement looks something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
end
</code></pre></div></div>

<p>An <code class="highlighter-rouge">if</code> statement can optionally include an <code class="highlighter-rouge">else</code> clause as well as an any
number of <code class="highlighter-rouge">elif</code> (else-if) clauses:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
elif x &gt; 5
  print "x is greater than 5";
else
  print "x is between 1 and 5";
end
</code></pre></div></div>

<p>Simit supports the following logical operators and comparison operators, which
can be used to construct more complex conditions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x or y;   % Logical OR
x and y;  % Logical AND
x xor y;  % Logical XOR
not x;    % Logical NOT

a == b;   % Equality
a != b;   % Inequality
a &lt; b;    % Less than
a &lt;= b;   % Less than or equal to
a &gt; b;    % Greater than
a &gt;= b;   % Greater than or equal to
</code></pre></div></div>

<p>For example, if we only cared about the scenario in which the value of <code class="highlighter-rouge">x</code> is
between 1 and 5, then we could have simply written:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &gt;= 1 and x &lt;= 5
  print "x is between 1 and 5";
end
</code></pre></div></div>

<p>In fact, we can write the test even more succinctly by chaining comparisons:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if 1 &lt;= x &lt;= 5
  print "x is between 1 and 5";
end
</code></pre></div></div>

<h2 id="while-loops">While Loops</h2>

<p>A <code class="highlighter-rouge">while</code> loop in Simit looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while x &lt; 100
  x = 2 * x;
end
</code></pre></div></div>

<p>As with <code class="highlighter-rouge">if</code> statements, logical operators and comparison operators can be used
to construct more complex conditions. Note that if the condition of a <code class="highlighter-rouge">while</code>
loop is false when a Simit program first encounters the loop, the loop body
will not be executed at all.</p>

<h2 id="do-while-loops">Do-While Loops</h2>

<p>A <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">while</code> loop in Simit looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do
  x = 2 * x;
end while x &lt; 100
</code></pre></div></div>

<p>In contrast to <code class="highlighter-rouge">while</code> loops, the body of a <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">while</code> loop is guaranteed to
be executed at least once even if the condition is never true.</p>

<h2 id="for-loops">For Loops</h2>

<p>Simit <code class="highlighter-rouge">for</code> loops are more like those found in MATLAB, Julia and Python than
those available in C. They can be used to iterate over elements in a Simit set.
For example (pun intended):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for p in points
  % Do some computation with element p in points set
end
</code></pre></div></div>

<p>You can also use a <code class="highlighter-rouge">for</code> loop to iterate over the set of all integers between
two values, as shown in the following example.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in 0:10
  print i;
end
</code></pre></div></div>

<p>Note that the lower bound is <em>inclusive</em> while the upper bound is <em>exclusive</em>
(like Python), so the above example prints all integers between 0 and 9 but
omits 10.</p>

<h1 id="vectors-and-matrices">Vectors and Matrices</h1>
<p>Vector and matrix variables have types, and in the simplest case these just
define the size of each dimension:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% A column vector of three floats
var row : vector[3](float);

% A row vector of three floats
var col : vector[3](float)';

% A 3 x 3 matrix of floats
var mat : matrix[3,3](float);
</code></pre></div></div>

<p>Vectors and matrices can also be blocked:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% A 3-vector with 2-vector blocks
var vec : vector[3](vector[2](float));
</code></pre></div></div>

<p>There are two types of vector/matrix dimensions. The examples above show
vectors and matrices with simple integer range dimensions. These are much like
one- and two-dimensional arrays in languages like C. However, vector and matrix
dimensions can also be Simit sets; this is explained in more detail in the
<a href="#system-vectors-and-matrices">System Vectors and Matrices</a> section.</p>

<h2 id="literals">Literals</h2>
<p>The syntax for declaring vector literals in Simit is similar to that of MATLAB,
as the following examples illustrate. Note that vector literals are <em>row-major</em>
by default; column vector literals can be created by transposing row vector
literals.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% A column 3-vector containing the gravity constant (g)
const gravity : vector[3](float) = [0.0, 0.0, 9.8]';

% Same as above, but with comma separators omitted
const gravity : vector[3](float) = [0.0 0.0 9.8]';

% Same as above, but with the type inferred
gravity = [0.0 0.0 9.8]';
</code></pre></div></div>

<p>Simit also supports the MATLAB syntax for declaring matrix literals in addition
to an alternative more regular syntax:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% 2 x 2 matrix of integers
mat = [1, 2; 3, 4];

% Same as above, but with comma separators omitted
mat = [1 2; 3 4];

% Same as above, but expressed in alternative syntax
mat = [[1, 2], [3, 4]];

% 2 x 1 matrix of floats
mat21 = [1.0; 2.0];

% 1 x 2 matrix of floats
mat12 = [[1, 2]];
</code></pre></div></div>

<h2 id="linear-algebra">Linear Algebra</h2>
<p>Simit supports a wide variety of basic linear algebra operations, as shown
below. (In the following examples, <code class="highlighter-rouge">b</code> and <code class="highlighter-rouge">c</code> are column vectors and <code class="highlighter-rouge">r</code> is 
a scalar.)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = b  + c;   % Vector addition
a = b  - c;   % Vector subtraction
a = b';       % Vector transpose
a = b' * c;   % Inner product
a = b  * c';  % Outer product

A = B + C;    % Matrix addition
A = B - C;    % Matrix subtraction
A = B * C;    % Matrix multiplication
A = B';       % Matrix transpose

a = r  * b;   % Scalar-vector multiplication
a = b  * r;   % Vector-scalar multiplication
A = r  * B;   % Scalar-matrix multiplication
A = B  * r;   % Matrix-scalar multiplication
A = B  * c;   % Matrix-vector multiplication
A = b' * C;   % Vector-matrix multiplication

a = b .* c;   % Vector component-wise multiplication
a = b ./ c;   % Vector component-wise division
A = B .* C;   % Matrix element-wise multiplication
A = B ./ C;   % Matrix element-wise division

x = A \ b;    % Solve Ax = b
</code></pre></div></div>

<p>Linear algebra operations can be composed to form complex expressions. For
instance, the following example multiplies the sum of two matrices <code class="highlighter-rouge">B</code> and <code class="highlighter-rouge">C</code>
by the component-wise product of two column vectors <code class="highlighter-rouge">d</code> and <code class="highlighter-rouge">e</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = (B + C) * (d .* e);
</code></pre></div></div>

<h2 id="indexing">Indexing</h2>
<p>Vectors and matrices can be indexed using parentheses, but unlike MATLAB
indices are zero-based.  Note that initializing a vector or a matrix by a
scalar literal sets every component to the scalar value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a : vector[2](float) = 0.0;
a(0) = 1.0;  
print a;  % a == [1.0, 0.0]'

var A : vector[2,3](float) = 0.0;
A(0,2) = 1.0;
print A;  % [0.0, 0.0, 1.0; 0.0, 0.0, 0.0]
</code></pre></div></div>

<p>Blocked vectors and matrices can be indexed using multiple parentheses.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a : vector[3](vector[2](float)) = 0.0;
a(1) = [1.0, 2.0]';
a(2)(1) = 3.0;
print a';  % [0.0, 0.0, 1.0, 2.0, 0.0. 3.0]'
</code></pre></div></div>

<h2 id="slicing">Slicing</h2>
<p>You can also use the <code class="highlighter-rouge">:</code> operator to select a single row or column from a
matrix:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A : matrix[2,2](float) = [1.0, 2.0; 3.0, 4.0];
print A(:, 1);  % [2.0, 4.0]

</code></pre></div></div>

<h2 id="generic-range-dimensions">Generic Range Dimensions</h2>

<p>In all of the examples above, vectors and matrices have range dimensions that
are integer literals. Very often though, you want to define functions that work
with vectors and matrices of arbitrary sizes as opposed to some fixed sizes,
similar to how operators like <code class="highlighter-rouge">+</code> and <code class="highlighter-rouge">*</code> can operate on vectors and matrices
of any size. This can be done with generics as demonstrated by the following
function that takes two vectors of any length and returns their element-wise
maximum:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func max&lt;0:N&gt;(a : vector[N](int), b : vector[N](int)) 
    -&gt; c : vector[N](int)
  for k in 0:N
    if a(k) &gt;= b(k)
      c(k) = a(k);
    else
      c(k) = b(k);
    end
  end
end
</code></pre></div></div>

<p>The prefix <code class="highlighter-rouge">0:</code> in the declaration of the generic parameter tells the compiler
that <code class="highlighter-rouge">N</code> must represent an integer range (as opposed to a Simit set). This
allows us to use <code class="highlighter-rouge">N</code> anywhere within the function body as a constant integer
whose value is the upper bound of the range represented by the generic
parameter, as we did on the first line of the <code class="highlighter-rouge">for</code> loop in <code class="highlighter-rouge">max</code>.</p>

<p>We can now call <code class="highlighter-rouge">max</code> in the rest of our program with integer-dimensioned
vectors of any length as inputs:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = [0, 2, 4, 6, 8]';
b = [9, 7, 5, 3, 1]';
print max(a, b);  % == [9, 7, 5, 6, 8]'

u = [1, 3, 5]';
v = [2, 3, 4]';
w = max(u, v);  % w == [2, 3, 5]'
</code></pre></div></div>

<p>However, the following program would not compile because <code class="highlighter-rouge">max</code> can only accept 
two vectors that are of the same length:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = [1, 2, 3]';
b = [5, 6, 7, 8]';
c = max(a, b);
</code></pre></div></div>

<p>Observe that we never had to explicitly specify the value of <code class="highlighter-rouge">N</code> when calling
<code class="highlighter-rouge">max</code>, since the compiler can deduce what <code class="highlighter-rouge">N</code> has to be from the dimensions of
the inputs. Occasionally it might not be possible for the compiler to deduce
what the generic arguments to a function call are. Consider this next example,
which is a function that outputs an arithmetic sequence:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func arithSeq&lt;0:N&gt;(a0 : int, d : int)
    -&gt; a : vector[N](int)
  for k in 0:N
    a(k) = a0 + k * d;
  end
end
</code></pre></div></div>

<p>None of the inputs to <code class="highlighter-rouge">arithSeq</code> has a type that is parameterized by <code class="highlighter-rouge">N</code>, so in
order to call <code class="highlighter-rouge">arithSeq</code> the value of <code class="highlighter-rouge">N</code> has to be explicitly specified as
part of the function call:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = arithSeq&lt;5&gt;(1,2);  % a == [1, 3, 5, 7, 9]'
</code></pre></div></div>

<h1 id="system-data-structures">System Data Structures</h1>
<p>So far we have focused on basic constructs and data types. We will now look at
the advanced types that are used to describe the structure of whole physical
systems as well as the <em>global</em> properties of these systems. This is the part
where Simit starts to look and feel very different from other languages like
MATLAB and Julia.</p>

<p>In Simit, the topolog of a system is expressed with a <em>hypergraph</em> data
structure and global properties are described using system vectors and
matrices. A <em>system</em> vector or matrix is a vector or matrix whose dimension
sizes are proportional to the size of the whole system, as opposed to an
<em>element</em> vector or matrix whose sizes are integer ranges.</p>

<h2 id="elements-sets-and-graphs">Elements, Sets and Graphs</h2>
<p>Elements, sets and graphs form Simit’s <em>data model</em>, which is the way you
represent your system.</p>

<h3 id="elements">Elements</h3>
<p>An element is a type that stores one or more data fields, much like a struct in
C/C++. For example, an element representing a point may store a position vector
<code class="highlighter-rouge">x</code> and a velocity vector <code class="highlighter-rouge">v</code>, while an element represent a spring may store a
scalar mass:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Point
  x : vector[3](float);
  v : vector[3](float);
end

element Element
  m : float;
  l : float;
end
</code></pre></div></div>

<p>To read from or write to a field of an Element <code class="highlighter-rouge">e</code> or a Point <code class="highlighter-rouge">p</code>, you use the
<code class="highlighter-rouge">.</code> operator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e.m = 2.0;
print e.m;  % 2.0

p.x = [0.0, 0.0, 1.0]';
print p.x;  % [0.0, 0.0, 1.0]'
</code></pre></div></div>

<h3 id="sets">Sets</h3>
<p>Unlike C structs, elements live in sets. So Point elements must be stored in
some set, such as <code class="highlighter-rouge">points</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern points : set{Point};
</code></pre></div></div>

<p>The <code class="highlighter-rouge">extern</code> keyword simply means that the <code class="highlighter-rouge">points</code> set comes from outside the
Simit program. Typically they have been assembled using the <a href="api">Simit
C++API</a>.</p>

<p>The best ways to work with sets are to
<a href="#apply-stencil-update-functions">apply stencil update functions</a> and to
<a href="#assemble-system-vectors-and-matrices">assemble system vectors or matrices</a>.</p>

<h3 id="edge-sets">Edge Sets</h3>
<p>Edge sets are sets that also have connectivity information. In particular, edge
set definitions specify the list of sets from which each edge’s endpoints come.
The following declares a set of spring elements that each connect two points
from the <code class="highlighter-rouge">points</code> set:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern springs : set{Element}(points,points);
</code></pre></div></div>

<p>There is no explicit graph type in Simit; rather, graphs are formed implicitly
from the combination of sets and edge sets. This is similar to how graphs are
often defined in mathematical papers (i.e. as an ordered pair <code class="highlighter-rouge">G = (V,E)</code>).</p>

<p>Simit’s graphs are hypergraphs, which just means that edges can have more (or
less) than two endpoints. More precisely, a Simit graph is a <em>k</em>-uniform
hypergraphs; in other words, each edge can (and must) connect <em>k</em> vertices,
where <em>k</em> is some non-negative integer constant. Thus, we can declare
additional edge sets that contain triangle, tetrahedral or even hexahedral
elements, as demonstrated below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern triangles  : set{Element}(points,points,points);
extern tetrahedra : set{Element}(points * 4);
extern hexahedra  : set{Element}(points * 6);
</code></pre></div></div>

<p>The <code class="highlighter-rouge">tetrahedra</code> and <code class="highlighter-rouge">hexahedra</code> sets are <em>homogeneous</em> edge sets. This means
that all of their endpoints are elements from the same set. Because of this we
could use a syntactic shortcut to declare their endpoint lists, which freed us
from writing out <code class="highlighter-rouge">point</code> four or six times.  The two ways to declare
homogeneous edge sets shown above are equivalent.</p>

<p>That said, the more verbose syntax also lets us declare <em>heterogeneous</em> edge
sets, which are edge sets that can connect two or more <em>different</em> sets. For
instance, the <code class="highlighter-rouge">links</code> edge set below connects a set of triangles to a set of
tetrahedra.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern links : set{Link}(triangles, tetrahedra);
</code></pre></div></div>

<h3 id="grid-edge-sets">Grid Edge Sets</h3>
<p>Simit also supports declaring edge sets which connect points in a regular
grid pattern with a particular dimensionality. The following declares a
three-dimensional grid over the <code class="highlighter-rouge">points</code> set, meaning it contains links
connecting each point to six other points (in the six cardinal directions
one can move for a three-dimensional grid):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern springsGrid : grid[3]{Element}(points);
</code></pre></div></div>

<p>While one could build such a structure using a generic edge set, specifying this
structure enables <a href="#coordinate-based-access">coordinate-based accessing</a> when
assembling matrices based on grid edge sets.</p>

<p>Because these edge sets have very particular structure, extern grid edge sets
are assembled with different syntax in the <a href="api">Simit C++ API</a>.</p>

<h2 id="apply-stencil-update-functions">Apply Stencil Update Functions</h2>

<p>A stencil update function is any function that takes as arguments an element
and (if the element is an edge) its endpoints. A stencil update function that
writes to the input element is called a <em>gather</em> (or <em>pull</em>) stencil, while a
stencil update function that writes to the endpoints is called a <em>scatter</em> (or
<em>pull</em>) stencil. The following stencil function moves a point one unit in the x
direction. The <code class="highlighter-rouge">inout</code> keyword declares that <code class="highlighter-rouge">p</code> can be written to.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func move(inout p : Point)
  p.x(0) = p.x(0) + 1.0;
end
</code></pre></div></div>

<p>Stencil update functions are applied to every element of a set concurrently
using an <code class="highlighter-rouge">apply</code> statement. The following statement moves every point in the
<code class="highlighter-rouge">points</code> set one unit in the x direction:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply move to points;
</code></pre></div></div>

<p>Since <code class="highlighter-rouge">move</code> only takes a single point as input, the stencil can access just
that one point and therefore has a completely local effect.</p>

<p>A stencil update function that takes an edge from an edge set as input can
access the element as well as the endpoints corresponding to that edge. As an
example, the following stencil takes a spring, computes its length and stores
the length into the <code class="highlighter-rouge">l</code> field of the corresponding element:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func length(inout s : Element,  p : (src : Point, dst : Point))
  s.l = norm(p.dst.x - p.src.x);
end
</code></pre></div></div>

<p>In the function definition above, <code class="highlighter-rouge">p</code> is a tuple containing the two endpoints
of the spring. To be more precise, <code class="highlighter-rouge">p</code> is a <em>named</em> (or <em>heterogeneous</em>) tuple,
meaning its elements can be accessed by name using the <code class="highlighter-rouge">.</code> operator. Note that
since all elements of <code class="highlighter-rouge">p</code> are actually of the same element type, we could have
instead declared <code class="highlighter-rouge">p</code> as an <em>unnamed</em> (or <em>homogeneous</em>) tuple that is indexed
by integral indices using parentheses, as the following equivalent definition
of <code class="highlighter-rouge">length</code> demonstrates:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func length(inout s : Element, p : (Point*2))
  s.l = norm(p(1).x - p(0).x);
end
</code></pre></div></div>

<p>Now to update the lengths of all spring elements in the <code class="highlighter-rouge">springs</code> set, we again
use an apply statement:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply length to springs;
</code></pre></div></div>

<h2 id="system-vectors-and-matrices">System Vectors and Matrices</h2>
<p>In addition to integer ranges, the dimensions of vectors and matrices can be 
<em>sets</em>. We call such vectors and matrices <em>system</em> vectors and matrices, and 
they can describe properties of an entire physical system. A system vector can 
be thought of as a dictionary, while a system matrix can be thought of as a
two-dimensional dictionary (or a dictionary of dictionaries):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% A vector with one float per point in the points set
var a : vector[points](float);

% A vector with one 3-vector block per point 
% in the points set
var b : vector[points](vector[3](float));

% A matrix with one 3x3 matrix block non-empty 
% per pair of points in the points set
var K : matrix[points,points](matrix[3,3](float));
</code></pre></div></div>

<p>Note that system matrices can be sparse matrices and do not have to store 
values for all |<code class="highlighter-rouge">points</code>|<sup>2</sup> combinations of indices.</p>

<p>In the <a href="#elements">Elements</a> section, we showed how an element field can be 
accessed using the <code class="highlighter-rouge">.</code> operator. Sets also have fields, corresponding to the 
fields of the set elements, that can be accessed using the same syntax. The 
result of a set field read is a system vector that is constructed by 
concatenating the corresponding fields of all elements in the set. For example, 
if set <code class="highlighter-rouge">springs</code> contains elements <code class="highlighter-rouge">e0</code>, <code class="highlighter-rouge">e1</code> and <code class="highlighter-rouge">e2</code> (in that order) and if 
each element has a field <code class="highlighter-rouge">m</code> of type <code class="highlighter-rouge">float</code>, then <code class="highlighter-rouge">springs.m</code> would correspond 
to the system vector</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[e0.m, e1.m, e2.m]'
</code></pre></div></div>

<p>and would be of type <code class="highlighter-rouge">vector[springs](float)</code>.</p>

<h2 id="assemble-system-vectors-and-matrices">Assemble System Vectors and Matrices</h2>
<p>The key construct that ties sets to system vectors and matrices is the vector
or matrix assembly. An assembly maps a set to a system vector or matrix. Its
semantics is very intuitive and lets the programmer describe system vectors and
matrices as sums of contributions from the elements of a set. An assembly map
expression, like the stencil apply, applies a local stencil function (called an
assembly function) to each element of a set. However, each assembly function
invocation returns a system vector and/or matrix, which are then added together
by the assembly map. That is, an assembly function is a stencil function that
returns one or more system vectors and matrices.</p>

<p>To assemble a force vector, each assembly function call returns a system vector
with the force produced by a single element:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func tet_force(tet : Element, p : (Point*4))
    -&gt; f : vector[points](vector[3](float))
  for i in 0:4
    f(p(i)) = compute_tet_force(tet,p,i);
  end
end
</code></pre></div></div>

<p>Note that each <code class="highlighter-rouge">tet_force</code> invocation only has access to the four points of one
tetrahedra and can therefore only write to four locations in the force vector.
This is a very important constraint, which both prevents indexing errors and
lets the compiler produce fast code since it knows how matrices relate to the
graph. The assumption is that your sparse system only directly interacts
locally. That is, if you want two elements to directly interact through a
matrix then you need to connect them with an edge. (Of course, elements will
often indirectly interact in your time stepper, for example by repeated
matrix-vector multiplications or as a result of a linear solve.)</p>

<p>The assembly function is applied to the elements of the tetrahedra set using an
assembly map expression to assemble the force vector for the whole system:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = map tet_force to tetrahedra reduce +;
</code></pre></div></div>

<p>To assemble a system stiffness matrix each assembly function call returns an
element stiffness matrix, which is a system stiffness matrix with the
contribution of just one element:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func tet_stiffness(tet : Element, p : (Point*4))
    -&gt; K : matrix[points,points](matrix[3,3](float))
  for i in 0:4
    for j in 0:4
     K(p(i),p(j)) = compute_tet_stiffness(tet,p,i,j);
    end
  end
end
</code></pre></div></div>

<p>The assembly function is applied to the elements of the tetrahedra set using an
assembly map expression to assemble the stiffness matrix for the whole system:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>K = map tet_stiffness to tetrahedra reduce +;
</code></pre></div></div>

<h2 id="coordinate-based-access">Coordinate-Based Access</h2>
<p>In
<!-- not supported yet: [applying stencil update functions]
     (#apply-stencil-update-functions) and -->
<a href="#assembly-system-vectors-and-matrices">assembling system matrices and vectors</a>
using grid edge sets, Simit also supports coordinate-based access. Enabling
coordinate-based access requires supplying a grid edge set using the <code class="highlighter-rouge">through</code>
syntax. The following demonstrates a vector assembly with grid coordinates:
<!-- not supported yet:
The following demonstrates a stencil update application with grid
coordinates enabled: --></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v = map average to points through springsGrid;
</code></pre></div></div>

<p>Using coordinate-based access within the assembly function requires accepting
the grid edge set as additional argument to the function. The underlying node
set may then by indexed by coordinate indices <em>relative</em> to the origin node
(the first argument) using brackets and constant integer offets. The following
demonstrates assembling an average value vector incorporating elements one hop
away in all cardinal directions.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func average(p : Point, links : grid[3]{Element}(points))
    -&gt; v : vector[points](float)
  v(p) = (0.167)*(points[1,0,0].val + points[-1,0,0].val +
                  points[0,1,0].val + points[0,-1,0].val +
                  points[0,0,1].val + points[0,0,-1].val);
end
</code></pre></div></div>

<p>The links passed for coordinate-based access not only provide structure but may
also be accessed as part of the stencil function. To access a link, one must
specify both the source and sink of the link in brackets, separated by a
semicolon. The following demonstrates assembling a force vector for a grid of
springs with individual spring constants:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func spring_force(p : Point, points : set{Point},
                  springs : grid[2]{Spring}(points))
    -&gt; f : vector[points](vector[3](float))
  force1 = (points[1,0].x - p.x) * springs[0,0; 1,0].k;
  force2 = (points[0,1].x - p.x) * springs[0,0; 0,1].k;
  force3 = (points[-1,0].x  - p.x) * springs[0,0; -1,0].k;
  force4 = (points[0,-1].x - p.x) * springs[0,0; 0,-1].k;
  f(p) = force1 + force2 + force3 + force4;
end
</code></pre></div></div>

<p>This assembly function is applied to the elements of the point set using an
assembly map expression with the <code class="highlighter-rouge">through</code> keyword:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = map spring_force to points through springsGrid;
</code></pre></div></div>

<h2 id="generic-set-dimensions">Generic Set Dimensions</h2>
<p>Generics in Simit also work with vectors and matrices whose dimensions are sets
as opposed to integer ranges. As an example, the following function takes any
system (or even non-system) matrix of any size and finds the largest element in
the matrix (albeit in a suboptimal fashion for sparse matrices):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func max&lt;M,N&gt;(A : matrix[M,N](float)) -&gt; b : float
  b = -1.0 / 0.0;  % Initialize b to -inf
  for m in M
    for n in N
      if A(m,n) &gt; b
        b = A(m,n);
      end
    end
  end
end
</code></pre></div></div>

<p>Observe that iterating over a generic set is allowed. However, it is illegal to
access the field of an element of a generic set.</p>

<p>Generics can also be used to define assembly functions that can be mapped to
arbitrary sets (as long as they contain the same types of elements). For
instance, the assembly function <code class="highlighter-rouge">tet_force</code> from the previous section can be
redefined as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func tet_force&lt;S&gt;(tet : Element, p : (Point*4))
    -&gt; f : vector[S](vector[3](float))
  for i in 0:4
    f(p(i)) = compute_tet_force(tet,p,i);
  end
end
</code></pre></div></div>

<p>The above function can then be used to assemble the force vector as before:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = map tet_force to tetrahedra reduce +;
</code></pre></div></div>

<p>Once again, observe that we did not have to explicitly state what set <code class="highlighter-rouge">S</code>
corresponds to when mapping <code class="highlighter-rouge">tet_force</code> to the <code class="highlighter-rouge">tetrahedra</code> set. Since elements
of tuple <code class="highlighter-rouge">p</code> are used to index into the result vector <code class="highlighter-rouge">f</code> in the body of
<code class="highlighter-rouge">tet_force</code>, the compiler would actually be able to deduce that <code class="highlighter-rouge">S</code> must
correspond to the set that contains the elements of <code class="highlighter-rouge">p</code>, which in the case of
the assembly map must be the <code class="highlighter-rouge">points</code> set (the edge set of <code class="highlighter-rouge">tetrahedra</code>).</p>

<h1 id="built-in-functions">Built-in Functions</h1>
<p>The following functions are built into Simit:</p>

<h2 id="scalar-math">Scalar Math</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Arguments</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">mod</code></td>
      <td><code class="highlighter-rouge">a : int, b : int</code></td>
      <td><code class="highlighter-rouge">c : int</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">sin</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">cos</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">tan</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">asin</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">acos</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">atan2</code></td>
      <td><code class="highlighter-rouge">a : float, b : float</code></td>
      <td><code class="highlighter-rouge">c : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">sqrt</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">log</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">exp</code></td>
      <td><code class="highlighter-rouge">a : float</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">pow</code></td>
      <td><code class="highlighter-rouge">a : float, b : float</code></td>
      <td><code class="highlighter-rouge">c : float</code></td>
    </tr>
  </tbody>
</table>

<h2 id="linear-algebra-1">Linear Algebra</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Arguments</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">det</code></td>
      <td><code class="highlighter-rouge">A : matrix[3,3](float)</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">inv</code></td>
      <td><code class="highlighter-rouge">A : matrix[3,3](float)</code></td>
      <td><code class="highlighter-rouge">A : matrix[3,3](float)</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">norm&lt;N&gt;</code></td>
      <td><code class="highlighter-rouge">a : vector[V](float)</code></td>
      <td><code class="highlighter-rouge">b : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">dot&lt;N&gt;</code></td>
      <td><code class="highlighter-rouge">a : vector[V](float),</code> <br /> <code class="highlighter-rouge">b : vector[V](float)</code></td>
      <td><code class="highlighter-rouge">c : float</code></td>
    </tr>
  </tbody>
</table>

<h2 id="solvers">Solvers</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Arguments</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">chol</code></td>
      <td><code class="highlighter-rouge">A : matrix[V,V](float)</code></td>
      <td><code class="highlighter-rouge">solver : opaque</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">cholfree</code></td>
      <td><code class="highlighter-rouge">solver : opaque</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lltsolve</code></td>
      <td><code class="highlighter-rouge">solver : opaque,</code> <br /> <code class="highlighter-rouge">A : matrix[V,V](float),</code> <br /> <code class="highlighter-rouge">b : vector[V](float)</code></td>
      <td><code class="highlighter-rouge">x : vector[V](float)</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lltmatsolve</code></td>
      <td><code class="highlighter-rouge">solver : opaque,</code> <br /> <code class="highlighter-rouge">A : matrix[V,V](float),</code> <br /> <code class="highlighter-rouge">B : vector[V,V](float)</code></td>
      <td><code class="highlighter-rouge">x : vector[V](float)</code></td>
    </tr>
  </tbody>
</table>

<h2 id="complex-math">Complex Math</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Arguments</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">createComplex</code></td>
      <td><code class="highlighter-rouge">r : float, i : float</code></td>
      <td><code class="highlighter-rouge">c : complex</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">complexNorm</code></td>
      <td><code class="highlighter-rouge">c : complex</code></td>
      <td><code class="highlighter-rouge">n : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">complexGetReal</code></td>
      <td><code class="highlighter-rouge">c : complex</code></td>
      <td><code class="highlighter-rouge">r : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">complexGetImag</code></td>
      <td><code class="highlighter-rouge">c : complex</code></td>
      <td><code class="highlighter-rouge">r : float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">complexConj</code></td>
      <td><code class="highlighter-rouge">a : complex</code></td>
      <td><code class="highlighter-rouge">b : complex</code></td>
    </tr>
  </tbody>
</table>


      </section>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/prism.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-79370201-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
