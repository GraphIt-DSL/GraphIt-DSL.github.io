<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>The GraphIt Programming Language</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="stylesheets/prism.css" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40269412-1']);
      _gaq.push(['_setDomainName', 'simit-lang.org']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index"><h1 class="title"> GraphIt</h1></a>
        <p>A high-performance graph domain specific language</p>
        <ul>
          <li><a href="http://github.com/yunmingzhang17/graphit">View On <strong>GitHub</strong></a></li>
        </ul>
	<p><a href="index">About</a></p>
        <p><a href="getting-started">Getting Started</a></p>
	<p><a href="python-getting-started">Python Binding Getting Started</a></p>
        <p><a href="language">Language Manual</a></p>
        <p><a href="publications">Publications</a></p>
	<p><a href="https://lists.csail.mit.edu/mailman/listinfo/graphit">Mailing List</a></p>
      </header>
      <footer>
        <p><a href="https://yunmingzhang.wordpress.com/">Yunming Zhang</a> <br>yunming at mit dot edu</p>
        <p><small>Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
      <section class="language-graphit">
      <h1 id="the-graphit-programming-language">The GraphIt Programming Language</h1>

<p class="no_toc">This guide introduces GraphIt language features and shows how they can be used in programs.</p>

<ul id="markdown-toc">
  <li><a href="#the-graphit-programming-language" id="markdown-toc-the-graphit-programming-language">The GraphIt Programming Language</a></li>
  <li><a href="#basics" id="markdown-toc-basics">Basics</a>    <ul>
      <li><a href="#functions" id="markdown-toc-functions">Functions</a></li>
      <li><a href="#primitive-types" id="markdown-toc-primitive-types">Primitive Types</a></li>
      <li><a href="#variables" id="markdown-toc-variables">Variables</a></li>
      <li><a href="#comments" id="markdown-toc-comments">Comments</a></li>
    </ul>
  </li>
  <li><a href="#control-flow-statements" id="markdown-toc-control-flow-statements">Control Flow Statements</a>    <ul>
      <li><a href="#if-statements" id="markdown-toc-if-statements">If Statements</a></li>
      <li><a href="#while-loops" id="markdown-toc-while-loops">While Loops</a></li>
      <li><a href="#for-loops" id="markdown-toc-for-loops">For Loops</a></li>
    </ul>
  </li>
  <li><a href="#elements-vectors-vertexsets-edgesets" id="markdown-toc-elements-vectors-vertexsets-edgesets">Elements, Vectors, VertexSets, EdgeSets</a>    <ul>
      <li><a href="#elements" id="markdown-toc-elements">Elements</a></li>
      <li><a href="#vectors" id="markdown-toc-vectors">Vectors</a></li>
      <li><a href="#edgesets" id="markdown-toc-edgesets">Edgesets</a></li>
      <li><a href="#vertexsets" id="markdown-toc-vertexsets">Vertexsets</a></li>
    </ul>
  </li>
  <li><a href="#built-in-operators" id="markdown-toc-built-in-operators">Built-in Operators</a>    <ul>
      <li><a href="#delete-operator" id="markdown-toc-delete-operator">Delete Operator</a></li>
      <li><a href="#parallel-sum-operator" id="markdown-toc-parallel-sum-operator">Parallel Sum Operator</a></li>
      <li><a href="#parallel-max-operator" id="markdown-toc-parallel-max-operator">Parallel Max Operator</a></li>
      <li><a href="#writemin-operator" id="markdown-toc-writemin-operator">writeMin Operator</a></li>
      <li><a href="#intersection-operator" id="markdown-toc-intersection-operator">Intersection Operator</a></li>
    </ul>
  </li>
  <li><a href="#set-operators" id="markdown-toc-set-operators">Set Operators</a>    <ul>
      <li><a href="#edgeset-operators" id="markdown-toc-edgeset-operators">Edgeset Operators</a>        <ul>
          <li><a href="#from-to-and-filter" id="markdown-toc-from-to-and-filter">from, to and filter</a></li>
          <li><a href="#srcfilter-and-dstfilter" id="markdown-toc-srcfilter-and-dstfilter">srcFilter and dstFilter</a></li>
          <li><a href="#apply" id="markdown-toc-apply">apply</a></li>
          <li><a href="#applymodified" id="markdown-toc-applymodified">applyModified</a></li>
          <li><a href="#edgeset-utility-functions" id="markdown-toc-edgeset-utility-functions">Edgeset Utility Functions</a></li>
          <li><a href="#combining-edgeset-operators" id="markdown-toc-combining-edgeset-operators">combining edgeset operators</a></li>
        </ul>
      </li>
      <li><a href="#vertexset-operators" id="markdown-toc-vertexset-operators">Vertexset Operators</a>        <ul>
          <li><a href="#filter" id="markdown-toc-filter">filter</a></li>
          <li><a href="#apply-1" id="markdown-toc-apply-1">apply</a></li>
          <li><a href="#addvertex" id="markdown-toc-addvertex">addVertex</a></li>
          <li><a href="#vertexset-utility-functions" id="markdown-toc-vertexset-utility-functions">Vertexset Utility Functions</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#extern-functions" id="markdown-toc-extern-functions">Extern Functions</a></li>
  <li><a href="#export-functions" id="markdown-toc-export-functions">Export Functions</a></li>
  <li><a href="#library-functions" id="markdown-toc-library-functions">Library Functions</a></li>
  <li><a href="#scheduling-language" id="markdown-toc-scheduling-language">Scheduling Language</a></li>
  <li><a href="#python-binding" id="markdown-toc-python-binding">Python Binding</a>    <ul>
      <li><a href="#graphit-language-extensions" id="markdown-toc-graphit-language-extensions">GraphIt language extensions</a></li>
      <li><a href="#type-mappings" id="markdown-toc-type-mappings">Type mappings</a>        <ul>
          <li><a href="#scalar-types-mappings" id="markdown-toc-scalar-types-mappings">Scalar types mappings</a></li>
          <li><a href="#non-scalar-types-mappings" id="markdown-toc-non-scalar-types-mappings">Non-scalar types mappings</a></li>
        </ul>
      </li>
      <li><a href="#python-module-api" id="markdown-toc-python-module-api">Python module API</a>        <ul>
          <li><a href="#graphitcompile_and_load" id="markdown-toc-graphitcompile_and_load"><code class="highlighter-rouge">graphit.compile_and_load</code></a></li>
          <li><a href="#graphitcompile_and_load_cache" id="markdown-toc-graphitcompile_and_load_cache"><code class="highlighter-rouge">graphit.compile_and_load_cache</code></a></li>
          <li><a href="#graphitgraphit_module" id="markdown-toc-graphitgraphit_module"><code class="highlighter-rouge">graphit.graphit_module</code></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="basics">Basics</h1>
<p>GraphIt is an imperative language with statements, control flow, and high-level operators on sts of vertices ane edges. In this section, we describe some of the languageâ€™s basic constructs.</p>

<h2 id="functions">Functions</h2>
<p>Functions can take any number of parameters, including none. Each parameter
must be declared with its name followed by its type (separated by a <code class="highlighter-rouge">:</code>). In
the following example, the function <code class="highlighter-rouge">add</code> takes two parameters named <code class="highlighter-rouge">a</code> and
<code class="highlighter-rouge">b</code>, both of which are of type <code class="highlighter-rouge">float</code>, and returns a single result (named <code class="highlighter-rouge">c</code>)
that is also a <code class="highlighter-rouge">float</code>. The function result is separated from the list of
parameters by a <code class="highlighter-rouge">-&gt;</code> and the function declaration is delimited by the <code class="highlighter-rouge">end</code>
keyword.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func add(a : float, b : float) -&gt; c : float
  c = a + b;
end
</code></pre></div></div>

<p>Like functions in MATLAB, GraphIt functions can return any number of results,
including none. In the next example, the function <code class="highlighter-rouge">minMax</code> takes two <code class="highlighter-rouge">float</code>
parameters and return two <code class="highlighter-rouge">float</code> results: the smaller of the two inputs as the
first result and the larger of the two inputs as the second result.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func minMax(a : float, b : float) 
    -&gt; (c : float, d : float)
  if a &lt; b
    c = a;
    d = b;
  else
    c = b;
    d = a;
  end
end
</code></pre></div></div>

<p>Note that the list of function results must be surrounded by parentheses if the
function returns more than one result. (The parentheses are optional if the
function returns just a single result.)</p>

<h2 id="primitive-types">Primitive Types</h2>
<p>GraphIt supports following primitive types so far:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int 
uint 
uint_64
float
double
bool

</code></pre></div></div>

<h2 id="variables">Variables</h2>
<p>Variables are declared in function bodies not in the global scope using the
<code class="highlighter-rouge">var</code> keyword. The following example declares an integer variable named <code class="highlighter-rouge">foo</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : int;
</code></pre></div></div>

<p>The variable can be initialized with the following syntax.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : float = 0.0;
</code></pre></div></div>

<p>The <code class="highlighter-rouge">const</code> keyword creates a variable that cannot be modified after
initialization.  Individual elements of const vectors can still be updated.</p>

<h2 id="comments">Comments</h2>
<p>Single-line comments start with <code class="highlighter-rouge">%</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h = 0.01;  % h is the time-step size.
</code></pre></div></div>

<p>Multi-line comments are surrounded by <code class="highlighter-rouge">%{</code> and <code class="highlighter-rouge">%}</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%{
h is the time-step size.
h is initialized to one millisecond.
%}
h = 0.001;
</code></pre></div></div>

<h1 id="control-flow-statements">Control Flow Statements</h1>
<p>GraphIt supports a variety of control flow constructs, including <code class="highlighter-rouge">if</code> statements,
<code class="highlighter-rouge">while</code> loops, <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">while</code> loops and <code class="highlighter-rouge">for</code> loops.</p>

<h2 id="if-statements">If Statements</h2>

<p>In GraphIt, a simple <code class="highlighter-rouge">if</code> statement looks something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
end
</code></pre></div></div>

<p>An <code class="highlighter-rouge">if</code> statement can optionally include an <code class="highlighter-rouge">else</code> clause as well as an any
number of <code class="highlighter-rouge">elif</code> (else-if) clauses:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
elif x &gt; 5
  print "x is greater than 5";
else
  print "x is between 1 and 5";
end
</code></pre></div></div>

<h2 id="while-loops">While Loops</h2>

<p>A <code class="highlighter-rouge">while</code> loop in GraphIt looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while x &lt; 100
  x = 2 * x;
end
</code></pre></div></div>

<p>As with <code class="highlighter-rouge">if</code> statements, logical operators and comparison operators can be used
to construct more complex conditions. Note that if the condition of a <code class="highlighter-rouge">while</code>
loop is false when a GraphIt program first encounters the loop, the loop body
will not be executed at all.</p>

<h2 id="for-loops">For Loops</h2>

<p>GraphIt <code class="highlighter-rouge">for</code> loops are more like those found in MATLAB, Julia and Python than
those available in C. You can use a <code class="highlighter-rouge">for</code> loop to iterate over the set of all integers between two values, as shown in the following example.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in 0:10
  print i;
end
</code></pre></div></div>

<p>Note that the lower bound is <em>inclusive</em> while the upper bound is <em>exclusive</em>
(like Python), so the above example prints all integers between 0 and 9 but
omits 10.</p>

<h1 id="elements-vectors-vertexsets-edgesets">Elements, Vectors, VertexSets, EdgeSets</h1>
<p>Elements, vertexsets, edgesets and vectors form GraphItâ€™s <em>data model</em>.</p>

<h2 id="elements">Elements</h2>
<p>An element is a type that stores one or more data fields, much like a struct in
C/C++. For example, a vertex in a social network representing a person can have a Person Element type. In the future, we plan to support fields in the Element. Currently, fields associated with an Element are expressed as separate Vectors descrived below.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Person
end
</code></pre></div></div>

<h2 id="vectors">Vectors</h2>

<p>Vectors are associated with an element. Essentially they act as fields of the elements. The following code says that <code class="highlighter-rouge">age</code> is a vector for <code class="highlighter-rouge">Person</code> Element type. Each Person would have an associated age field, and the field is initialized to 0.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const age : vector {Person}(int) = 0;

</code></pre></div></div>

<p>For vector for vertices, the user can access with a vertexid, in this case <code class="highlighter-rouge">age[v]</code>. For vector for edges, the user need to access with both src and destinaton vertexids, <code class="highlighter-rouge">edge_vector[src,dst]</code>.</p>

<h2 id="edgesets">Edgesets</h2>
<p>Edgesets have connectivity information. In particular, edge
set definitions specify the type of elements from which each edgeâ€™s endpoints come.
The following declares a set of <code class="highlighter-rouge">Edge</code> element that each connect two <code class="highlighter-rouge">Person</code> type points from the <code class="highlighter-rouge">edges</code> edgeset:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Edge}(Person,Person);
</code></pre></div></div>

<p>There is no explicit graph type in GraphIt; rather, graphs are formed implicitly
from the edgesets. This is similar to how graphs are
often defined in mathematical papers (i.e. as an ordered pair <code class="highlighter-rouge">G = (V,E)</code>).</p>

<h2 id="vertexsets">Vertexsets</h2>

<p>Vertexsets are sets of vertices of a specific Element Type. <code class="highlighter-rouge">people</code> is a vertexset made up of endpoint elements of Person Type from the <code class="highlighter-rouge">edges</code> edgeset.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const people : vertexset{Person} = edges.getVertices();

</code></pre></div></div>
<h1 id="built-in-operators">Built-in Operators</h1>
<h2 id="delete-operator">Delete Operator</h2>
<p>Delete operator is written as <code class="highlighter-rouge">delete</code> in graphit. It deallocates the memory for an object. It is very similar to <code class="highlighter-rouge">delete</code> keyword in C++. Simple usage is:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func main()
    var vertices : vertexset{Vertex} = edges.getVertices();
    delete vertices;
end

</code></pre></div></div>

<h2 id="parallel-sum-operator">Parallel Sum Operator</h2>
<p>Parallel sum operator is written as <code class="highlighter-rouge">.sum()</code> in graphit. When called on a vector of objects, it computes the sum in parallel. Simple usage is:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Vertex end
element Edge end

const edges : edgeset{Edge}(Vertex,Vertex) = load ("test.el");
const vertices : vertexset{Vertex} = edges.getVertices();
const vector_a : vector{Vertex}(float) = 0.0;

func main()
    % process vector_a
    ...
    #s2# var summation : float = vector_a.sum();
    print summation;
end

</code></pre></div></div>

<h2 id="parallel-max-operator">Parallel Max Operator</h2>
<p>Parallel sum operator is written as <code class="highlighter-rouge">.max()</code> in graphit. When called on a vector of objects, it finds the maximum value in the vector. Simple usage is:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Vertex end
element Edge end

const edges : edgeset{Edge}(Vertex,Vertex) = load ("test.el");
const vertices : vertexset{Vertex} = edges.getVertices();
const vector_a : vector{Vertex}(float) = 0.0;

func main()
    % process vector_a
    ...
    #s2# var summation : float = vector_a.max();
    print summation;
end

</code></pre></div></div>

<h2 id="writemin-operator">writeMin Operator</h2>
<p>writeMin operator atomically updates a value at some memory location by taking the minimum of the old value at that memory location and the new value. It return true if the value is updated, false otherwise. In GraphIt, writeMin operator takes three parameters - an array, index of the value, and new value.
Simple usage is:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Vertex, Vertex} = ...
const f_score : vector{Vertex}(int) = some_value;

func main()
    ...
    var new_f_score : int = f_score[src] + weight;
    var changed : bool = writeMin(f_score, dst, new_f_score);
end

</code></pre></div></div>
<h2 id="intersection-operator">Intersection Operator</h2>
<p>Intersection operator is written as <code class="highlighter-rouge">intersection</code> in graphit. It essentially intersects two sorted sets using different intersection methods. Simple usage is:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Vertex, Vertex} = ...

func main()
    ...
    var src_nghs : vertexset{Vertex} = edges.getNgh(src);
    var dst_nghs : vertexset{Vertex} = edges.getNgh(dst);
    var src_ngh_size : uint_64 = edges.getOutDegree(src);
    var dst_ngh_size : uint_64 = edges.getOutDegree(dst);
    var value: uint_64 = intersection(src_nghs, dst_nghs, src_ngh_size, dst_ngh_size);
end

</code></pre></div></div>
<p>Intersection operator takes four required arguments and one optional argument.</p>
<ul>
  <li><strong>intersection(v1: vertexset, v2: vertexset, n1: uint_64, n2: uint_64, ref: uint_64 = INF)</strong>: v1 and v2 are vertex sets we want to intersect while n1 and n2 are their respective sizes. We also have an optional parameter <code class="highlighter-rouge">ref</code> that tells us to not count vertices labeled beyond it. This is used for Triangular Counting algorithm to avoid double counting. This function returns <strong>number of common elements</strong> between two sets. Note that this operator only works for <strong>sorted</strong> sets.</li>
</ul>

<p>Since there are many ways to parallelize and implement this operation, we also provide scheduling interface to tune the intersection performance. The ones we support are:</p>
<ul>
  <li><strong>NaiveIntersection</strong>: Use two pointers to compute the intersection.</li>
  <li><strong>HiroshiIntersection</strong>: Compare elements of two sets 3 by 3. This helps with branch misprediction cost. You can take a look at original paper <a href="http://delivery.acm.org/10.1145/2740000/2735518/p293-inoue.pdf?ip=128.31.37.172&amp;id=2735518&amp;acc=ACTIVE%20SERVICE&amp;key=7777116298C9657D%2EDE5F786C30E1A3B4%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;__acm__=1571944913_e2e1fc50c82e33610791653f8cc373cf">here</a>. This works well when the input sets have comparable sizes.</li>
  <li><strong>BinarySearchIntersection</strong>: Look up elements of one list on the other one using binary search. This performs fast when the sizes of input sets are unbalanced.</li>
  <li><strong>MultiskipIntersection</strong>: Similar to <strong>NaiveIntersection</strong>, but it increments the pointer by 3 to skip unneccesary elements. This works well when the intersection is sparse.</li>
</ul>

<h1 id="set-operators">Set Operators</h1>
<h2 id="edgeset-operators">Edgeset Operators</h2>

<h3 id="from-to-and-filter">from, to and filter</h3>
<p><code class="highlighter-rouge">from</code> and <code class="highlighter-rouge">to</code> filters out edges whose source vertex is in the input set.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const people_age_over_40 : vertexset{Person} = ... 
const people_age_over_60 : vertexset{Person} = ...

func main()
  ...
  % find edges between people over 40 years old to people over 60 years old
  var filtered_edges : edgeset{Friend}(Person, Person} = 
       friend_edges.from(people_age_over_40).to(people_age_over_60);
end 

</code></pre></div></div>

<p><code class="highlighter-rouge">filter</code> simply supplies a boolean function that checks every edge.</p>

<h3 id="srcfilter-and-dstfilter">srcFilter and dstFilter</h3>

<p><code class="highlighter-rouge">srcFilter</code> and <code class="highlighter-rouge">dstFilter</code> filters out edges where the input boolean filtering function <code class="highlighter-rouge">filter_func</code> returns true.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func filter_func(v : Vertex) -&gt; output : bool
    output =  age[v] &gt; 40;
end

func main()
  ...
  filtered_edges = edges.srcFilter(filter_func);
  ...
end

</code></pre></div></div>

<h3 id="apply">apply</h3>

<p>This operator applies a function <code class="highlighter-rouge">updateEdge </code> to every edge. In one iteration of PageRank,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func updateEdge(src : Vertex, dst : Vertex)
    new_rank[dst] += contrib[src];
end

func main()
  ...
  edges.apply(updateEdge);
  ...
end
</code></pre></div></div>

<h3 id="applymodified">applyModified</h3>
<p>This operator applies a function (<code class="highlighter-rouge">updateEdge</code>) to every edge. Returns a vertexset that contains destination vertices whose entry in the vector has been modified in <code class="highlighter-rouge">updateEdge</code>. The programmer can optionally disable deduplication within modified vertices. Deduplication is enabled by default.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func updateEdge(src : Vertex, dst : Vertex)
    parent[dst] = src;
end

func main()
  ...
  edges.applyModified(updateEdge,parent, true);
  ...
end

</code></pre></div></div>

<h3 id="edgeset-utility-functions">Edgeset Utility Functions</h3>

<ul>
  <li><strong>getVertices(): -&gt; output : vertexset{Vertex}</strong> This returns a vertexset that is the union of source and destination nodes in the edgeset.</li>
  <li><strong>getOutDegrees() -&gt; vector{Vertex}(int):</strong> This returns a vector of outdegrees for all the vertices in the graph.</li>
  <li><strong>transpose() -&gt; transposed_edgeset : edgeset{Edge}(Vertex, Vertex)</strong>: This returns a transposed edgeset / graph.</li>
</ul>

<h3 id="combining-edgeset-operators">combining edgeset operators</h3>

<p>The various operators can be and often are chained together.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frontier = edges.from(frontier).to(toFilter).applyModified(updateEdge,parent, true);

</code></pre></div></div>

<h2 id="vertexset-operators">Vertexset Operators</h2>

<h3 id="filter">filter</h3>
<p>The filter operator is similar to the edgeset filter, except for it is applied on a single vertex and not edge.</p>

<h3 id="apply-1">apply</h3>
<p>The apply operator is similar to the edgeset apply operator, but applied to a vertex.</p>

<h3 id="addvertex">addVertex</h3>
<p>This operator adds a new vertex to vertexset. Example usage:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var frontier : vertexset{Vertex} = new vertexset{Vertex}(0);
frontier.addVertex(8);

</code></pre></div></div>

<h3 id="vertexset-utility-functions">Vertexset Utility Functions</h3>
<ul>
  <li><strong>getVertexSetSize(): output: int</strong> This returns the number of elements in the vertex set</li>
</ul>

<h1 id="extern-functions">Extern Functions</h1>

<p>The users can call functions implemented in C++ from GraphIt. These can be used in cases where the user needs some external functionalities that are not currently supported in the GraphIt language. For example, certain solvers or more complex operations that are not necessarily related to graphs. Another example could be a distance estimator used in AStar search.</p>

<p>The user needs to define a prototype of the function in the GraphIt program with the <code class="highlighter-rouge">extern</code> keyword. The example below defined a extern function named <code class="highlighter-rouge">extern_func</code> that takes as input a vertex and outputs a double.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern func extern_func(v: Vertex) -&gt; output:double; 
</code></pre></div></div>

<p>The users can use the extern function inside any function and it can be supplied as arguments to vertexset and edgeset operators. For exmaple, the extern_func can be supplied to the apply operator on a vertexset.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vertexset.apply(extern_func);
</code></pre></div></div>

<p>The users can also use vectors defined in the original GraphIt program inside the extern function. In the C++ definition of the extern programs, the user simply needs to declare an extern variable. The following example shows the definition of an extern function that reads a graphit_vector that is defined in the GraphIt program, and adds the value one to the vector for vertex v.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern double * graphit_vector;

double extern_func(v: NodeID){
  return graphit_vector[v] + 1;
}
</code></pre></div></div>

<p>To compile GraphIt programs, the user will first need to generate the C++ program with the GraphIt compiler. And later compile the generated file along with the other C++ file with the extern function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python graphitc.py -f graphit_file.gt -o graphit_generated.cpp 
g++ -std=c++11 -O3 -g -I ../../src/runtime_lib/ graphit_generated.cpp extern_func.cpp -o executable 
</code></pre></div></div>

<h1 id="export-functions">Export Functions</h1>

<p>The GraphIt compiler generate a stand alone executable with a main function by default. However, the user can also generate a library version of the function that can be used in the Python binding or just a regular C++ function using the export functions.</p>

<p>To declare an export function, the user simply uses the <code class="highlighter-rouge">export</code> keyword before the function that is going to be exported. The following example shows the definition of an export function <code class="highlighter-rouge">export_func</code> that takes as input a graph named <code class="highlighter-rouge">input_edges</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export func export_func(input_edges : edgeset{Edge}(Vertex,Vertex))
  ...
end
</code></pre></div></div>

<p>NOTE: the export function should NOT be named <code class="highlighter-rouge">main</code>. The <code class="highlighter-rouge">main</code> function name is reserved for standalone executable mode.</p>

<p>If the graph is passed in as argument to the exported function, then the vertexsets and vectors cannot be initialized in the const declarations. This is because the size of the vertexset and edgesets are not known at compile time. In this case, the user would need to manually initialize vertexsets and vectors. If the graph is not loaded in as an argument to the export function, then the user can continue to load the graph, initialize the vertexsets and vectors in const declarations.</p>

<p>Here we show an example to initilize the vertexsets and vectors when the graph is an input argument to the <code class="highlighter-rouge">export_func</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Edge}(Vertex,Vertex);
const vertices : vertexset{Vertex};
const float_vector : vector{Vertex}(float);

func initVector(v : Vertex)
     float_vector[v] = 0.0;
end

export func export_func(input_edges : edgeset{Edge}(Vertex,Vertex))
  edges = input_edges;
  vertices = edges.getVertices();
  float_vector = new vector{Vertex}(float)();
  vertices.apply(initVector);
end

</code></pre></div></div>

<h1 id="library-functions">Library Functions</h1>

<ul>
  <li><strong>getRandomOutNgh(v: Vertex)</strong>: This function returns a random outgoing neighbor of the Vertex v.</li>
  <li><strong>getRandomInNgh(v: Vertex)</strong>: This function returns a random incoming neighbor of the Vertex v.</li>
  <li><strong>getOutDegree(v: Vertex)</strong>: This function returns a degree of the Vertex v.</li>
  <li><strong>getOutNgh(v: Vertex)</strong>: This function returns a vertexset of neighbors of the Vertex v.</li>
  <li><strong>relabel()</strong>: This function relabels vertices based on heuristic. It is recommended to use this method for bigger graphs.</li>
  <li><strong>getRandomInNgh(v: Vertex)</strong>: This function returns a random incoming neighbor of the Vertex v.</li>
  <li><strong>serialMinimumSpanningTree(graph : edgeset{Vertex, Vertex, int}, start_vertex : Vertex) -&gt; output : vector{Vertex}(int)</strong>: This function computes a serial Minimum Spanning Tree computation on the weighted graph <code class="highlighter-rouge">graph</code> from the <code class="highlighter-rouge">start_vertex</code>. It returns a vector of VertexIDs (integers). This vector contains the parent VertexID for each Vertex v.</li>
  <li><strong>serialSweepCut(g : edgeset{Edge}(Vertex, Vertex), vset : vertexset{Vertex}, val_array : vector{Vertex}(double)) -&gt; output : vertexset{Vertex}</strong>: This function computes a sweep cut on the vertices based on values supplied with the <code class="highlighter-rouge">val_array</code>, and returns a subset of the vertexset that belongs to one side of the cut. This is an operator for local graph clustering operations as documented <a href="https://arxiv.org/abs/1604.07515">here</a>.</li>
  <li><strong>load(graph_file_name : string) -&gt; output : edgeset{Edge}(Vertex, Vertex)</strong>: This function returns an edgeset loaded from the external file. This can load either an unweighted or weighted file.</li>
  <li><strong>startTimer()</strong>: This function starts the timer.</li>
  <li><strong>stopTimer()</strong> -&gt; elapsed_time : float__: This function stops the timer and returns the elapsed time in floats</li>
  <li><strong>fabs()</strong>: This function returns the absolute value of a float.</li>
  <li><strong>atoi()</strong>: This function converts a string to an integer.</li>
</ul>

<p><strong>NOTE</strong>: If you need some library routine that is not included in the list, you can use the <a href="language#extern-functions">extern functions</a> to provide your customized functionalities.</p>

<h1 id="scheduling-language">Scheduling Language</h1>

<p>In this section, we provide some heuristics for tuning the schedules for improved performance. The scheduling language specified separately can tune the performance of the algorithm. The example below first described the algorithm with edgeset, vertexset, and the <code class="highlighter-rouge">main</code> function. The user can then use the <code class="highlighter-rouge">schedule:</code> keyword to mark the beginning of schedule spcification.</p>

<p>The label <code class="highlighter-rouge">#s1#</code> is used in the scheduling commands to identify the apply operator the schedule is applied on. The label <code class="highlighter-rouge">#s1</code> must be specified before the edgeset apply operator if the user intend to tune the performance of the operator.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Edge}(Vertex,Vertex);
const vertices : vertexset{Vertex};
const float_vector : vector{Vertex}(float);
...

func main ()
  ...
  #s1# edges.apply(updateEdge);
  ...
end

schedule:
  program-&gt;configApplyDirection("s1", "DensePull");
  ...

</code></pre></div></div>

<p>The full set of schedules are listed in the table below. We refer users to the Section 5 of the <a href="https://arxiv.org/abs/1805.00923">arxiv report</a> for details of scheduling language.</p>

<p><img src="gallery/schedules_with_intersection.png" alt="Scheduling Functions" /></p>

<p>Here are some general guidelines for selecting a set of schedules</p>

<ul>
  <li><strong>Step 1:</strong> Select a direction from SparsePush, DensePush, DensePull, SparsePush-DensePull with <code class="highlighter-rouge">configApplyDirection</code>. For large social networks that uses a frontier, SparsePush-DensePull is usually a good choice. For PageRank, DensePull is always the best. For road networks, SparsePush often is the best.</li>
  <li><strong>Step 2:</strong> Select a parallelization strategy with <code class="highlighter-rouge">configApplyParallelization</code>. Usually dynamic-vertex-parallel is the best. For road networks, it might better to switch to static-vertex-parallel. Edge-aware-dynamic-vertex-parallel is only better for PageRank and Collaborative Filtering in some cases.</li>
  <li><strong>Step 3:</strong> Select a layout for Dense Vertex Set with <code class="highlighter-rouge">configApplyDenseVertexset</code>. if a DensePull direction is used, then you can potentially to use bitvector for the vertexset when the graph has a large number of vertices (currently only working for the pull direction).</li>
  <li><strong>Step 4:</strong> If a DensePull direction is used, then you can use <code class="highlighter-rouge">configNumSSG</code> (currently only working for the pull direction) to partition the graph for cache efficiency. This is mostly useful for applications that spend a large amount of time processing all the edges (PageRank, PageRankDelta, and Collaborative Filtering). This optimization is usually hurtful for application that only touch a subset of vertices (BFS, SSSP, BC).  Calculations for the number of segments is based on the last level cache (LLC) size.</li>
  <li><strong>Step 5:</strong> <code class="highlighter-rouge">fuseFields</code> fuses fields that are accessed together into array of structurs to reduce the number of random accesses. Only needed for PageRankDelta so far.</li>
</ul>

<p>Some existing schedules 
There are many predfined schedules in the <a href="https://github.com/GraphIt-DSL/graphit/tree/master/test/input_with_schedules"><strong>input_with_schedules</strong> directory</a>. 
For a specific graph and application, the <a href="https://github.com/GraphIt-DSL/graphit/blob/master/graphit_eval/eval/table7/benchmark.py#L16">script</a> shows the best schedule.</p>

<p>In general, the following schedule achieves reasonable perforamnce on social networks (assuming the relevant edgeset apply operator is labeled with <code class="highlighter-rouge">#s1</code>).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schedule:
    program-&gt;configApplyDirection("s1","SparsePush-DensePull");
    program-&gt;configApplyParallelization("s1", "dynamic-vertex-parallel");
</code></pre></div></div>

<h1 id="python-binding">Python Binding</h1>

<p>GraphIt provides bindings for the user to load and call GraphIt functions in python. The algorithm with itâ€™s schedule can be written in a GraphIt file which can then be compiled and loaded using the GraphIt python module. 
In this section we describe how to build such an interface and how the types from GraphIt translate to python types and vice-versa.</p>

<h2 id="graphit-language-extensions">GraphIt language extensions</h2>

<p>The main difference between writing GraphIt programs and writing functions to be called from python is that GraphIt now compiles as a library instead of an executable program. So it doesnâ€™t contain a <code class="highlighter-rouge">main</code> function. Instead users can define any number of custom functions which can be separately invoked from python.</p>

<p>To separate internal helper functions from the function which are exposed as a part of the library, we add the <code class="highlighter-rouge">export</code> keyword. This keyword can be added to any function declaration before the <code class="highlighter-rouge">func</code> keyword. This tells the compiler that this function is supposed to be a part of the library to be called from python and sufficient wrappers should be generated for the same.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export func do_pagerank(edges: edgeset{Edge}, damp: double) -&gt; ranks: vector{Vertex}(float)
  ...
end
</code></pre></div></div>

<p>Notice how unlike the <code class="highlighter-rouge">main</code> function which doesnâ€™t take any arguments, export functions can take arguments for the graph and the required parameters for the algorithm which can be directly passed from the python code.</p>

<h2 id="type-mappings">Type mappings</h2>

<p>The bindings allow user to pass and return python objects over to the GraphIt functions. Python types are translated to GraphIt types and vice-versa using the following mapping. This mapping has been chosen to keep data copy to the minimum to ensure high performance. 
Just like regular python and GraphIt functions, the arguments are passed by reference and any modifications to non scalar types will reflect back in the python program. This feature can also be used if the user wishes to return multiple values.</p>

<h3 id="scalar-types-mappings">Scalar types mappings</h3>

<p>The scalar types in GrapIt directly map to their counterparts in python</p>

<table>
  <thead>
    <tr>
      <th>GraphIt type</th>
      <th>python type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">int</code></td>
      <td><code class="highlighter-rouge">int</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">float</code></td>
      <td><code class="highlighter-rouge">float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">long</code></td>
      <td><code class="highlighter-rouge">long</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">double</code></td>
      <td><code class="highlighter-rouge">double</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">bool</code></td>
      <td><code class="highlighter-rouge">bool</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Vertex</code></td>
      <td><code class="highlighter-rouge">int</code></td>
    </tr>
  </tbody>
</table>

<p>GraphIt currently doesnâ€™t have a <code class="highlighter-rouge">string</code> type. Hence <code class="highlighter-rouge">strings</code> cannot be passed or returned at this point.</p>

<h3 id="non-scalar-types-mappings">Non-scalar types mappings</h3>

<p>Following non-scalar types are currently supported as arguments and return values.</p>

<table>
  <thead>
    <tr>
      <th>GraphIt type</th>
      <th>python type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">edgeset{Edge}</code></td>
      <td><code class="highlighter-rouge">scipy.sparse.csr_matrix</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">vector{Vertex}(X)</code></td>
      <td><code class="highlighter-rouge">numpy.array(dtype=X)</code> (shape = <code class="highlighter-rouge">(num_vertices)</code>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">vector[n](X)</code></td>
      <td><code class="highlighter-rouge">numpy.array(dtype=X)</code> (shape= <code class="highlighter-rouge">(n)</code>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">vector{Vertex}(vector[n](X))</code></td>
      <td><code class="highlighter-rouge">numpy.array(dtype=X)</code> (shape = <code class="highlighter-rouge">(num_vertices, n)</code>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">vector[m](vector[n](X))</code></td>
      <td><code class="highlighter-rouge">numpy.array(dtype=X)</code> (shape = <code class="highlighter-rouge">(m, n)</code>)</td>
    </tr>
  </tbody>
</table>

<p>Here <code class="highlighter-rouge">X</code> is any scalar type mapped according to the mappings in the previous section. 
All the non-scalar types here are passed by reference except for the <code class="highlighter-rouge">edgeset{Edge}</code> type. This means that if the graph is updated in the Python code, it should be passed again.</p>

<p>The GraphIt test suite has examples on how to pass non-scalar types from python to GraphIt and returning it back. 
These test cases can be found in the <a href="https://github.com/GraphIt-DSL/graphit/blob/master/test/python/pybind_test.py"><code class="highlighter-rouge">pybind_test.py</code></a> file.</p>

<h2 id="python-module-api">Python module API</h2>

<p>To fascilate the user to load GraphIt libraries inside python and call into them we provide a module named <code class="highlighter-rouge">graphit</code> that can be imported on installed systems as</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import graphit
</code></pre></div></div>

<p>This module provides mainly the <code class="highlighter-rouge">compile_and_load</code> function which returns a <code class="highlighter-rouge">graphit.graphit_module</code> object. This object has all the functions which are exported from the GraphIt program.</p>

<h3 id="graphitcompile_and_load"><code class="highlighter-rouge">graphit.compile_and_load</code></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>graphit.compile_and_load(graphit_source_file, extern_cpp_files=[], linker_args=[], parallelization_type=graphit.PARALLEL_NONE)
</code></pre></div></div>
<p><em>Returns <code class="highlighter-rouge">graphit.graphit_module</code></em></p>

<p>The <code class="highlighter-rouge">compile_and_load</code> function is the primary function for using the python bindings for graphit. This function compiles the algorithm in the supplied <code class="highlighter-rouge">.gt</code> file and loads it as a python module with all the exported functions.</p>

<p><code class="highlighter-rouge">compile_and_load</code> takes a compulsory argument <code class="highlighter-rouge">graphit_source_file</code>. This is the relative/absolute path to the .gt file. The .gt file should contain both the algorithm and schedule if any. The schedule should be specified after the algorithm after the <code class="highlighter-rouge">schedule:</code> tag.</p>

<p>This function also takes an optional argument <code class="highlighter-rouge">extern_cpp_files</code>. If the algorithm needs to be linked with user provided .cpp files, they should be provided here as a list. This argument is necessary when using <code class="highlighter-rouge">extern</code> functions whose implementation is provided in a .cpp file. The list of files provided here will be compiled with appropriate GraphIt flag and linked with the module before loading. Note, you can only provide .cpp files here. Object files or static and shared libraries should not be provided here. They should be added to the <code class="highlighter-rouge">linker_args</code>.</p>

<p>The function also takes another optional argument <code class="highlighter-rouge">linker_args</code>, which is useful for providing extra arguments to the linker. These arguments are appended to the link command at the very end. Any extra object files or static/shared libraries can also be provided here. You should not provide .cpp files here because this command does not have appropriate compile flags. Source files should be provided with the <code class="highlighter-rouge">extern_cpp_files</code> argument.</p>

<p>Finally, the function takes an optional <code class="highlighter-rouge">parallelization_type</code> argument which can have the value <code class="highlighter-rouge">graphit.PARALLEL_NONE</code>, <code class="highlighter-rouge">graphit.PARALLEL_CILK</code> or <code class="highlighter-rouge">graphit.PARALLEL_OPENMP</code> (default is <code class="highlighter-rouge">graphit.PARALLEL_NONE</code>. This option allows the user to choose the parallelization runtime to use while compiling the GraphIt program.</p>

<p>The function returns a <code class="highlighter-rouge">graphit.graphit_module</code> object that has all the functions exported in the algorithm.</p>

<p><strong>Example with linker args</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import graphit
pagerank_module = graphit.compile_and_load("pagerank.gt", linker_args=["-lm"])
</code></pre></div></div>

<h3 id="graphitcompile_and_load_cache"><code class="highlighter-rouge">graphit.compile_and_load_cache</code></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>graphit.compile_and_load_cache(graphit_source_file, extern_cpp_files=[], linker_args=[], parallelization_type=graphit.PARALLEL_NONE)
</code></pre></div></div>
<p><em>Returns <code class="highlighter-rouge">graphit.graphit_module</code></em></p>

<p>This function behaves almost similar to <code class="highlighter-rouge">graphit.compile_and_load</code> except it tries to load the cached result if there was no modification.</p>

<h3 id="graphitgraphit_module"><code class="highlighter-rouge">graphit.graphit_module</code></h3>

<p>The <code class="highlighter-rouge">graphit.graphit_module</code> type object provides an interface to call into exported GraphIt functions. The functions have the exact same name as it had in the GraphIt file. The arguments follow the same name and order.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from scipy.sparse import csr_matrix
my_graph = load_npz("road-usad.npz")

ranks = pagerank_module.do_pagerank(edges=my_graph, damp=0.85)

</code></pre></div></div>
<p>The ranks which is of type <code class="highlighter-rouge">numpy.array(dtype=float)</code> can now be iterated over and its values used for further processing.</p>

<p><strong>Example with extern cpp files</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import graphit
import scipy.io
from scipy.sparse import csr_matrix
src_add_one_module = graphit.compile_and_load("export_extern_simple_edgeset_apply.gt", extern_cpp_files=["extern_src_add_one.cpp"])

my_graph = csr_matrix(scipy.io.mmread("4.mtx"))
sum_returned = src_add_one_module.export_func(graph)
</code></pre></div></div>

<p>In this example, the <code class="highlighter-rouge">export_extern_simple_edgeset_apply.gt</code> file declares an <code class="highlighter-rouge">extern</code> function <code class="highlighter-rouge">extern_src_add_one</code> which takes a source and destination and performs an operation on the source nodeâ€™s data. This function is called from the <code class="highlighter-rouge">edgeset.apply</code> operator. But the implementation of this function is not provided in the .gt file. It is provided as a cpp function in the cpp file <code class="highlighter-rouge">extern_src_add_one.cpp</code>. So we have provide a list containing the name of this file as the argument <code class="highlighter-rouge">extern_cpp_files</code>. This file is compiled separately when the module is compiled and linked in to the generated graphit module. If this argument is not provided, the compilation will fail with the linker error - <em>Undefined symbol: <code class="highlighter-rouge">extern_src_add_one</code></em>.</p>

<p><strong>Example with the parallelization type flag</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import graphit
pagerank_module = graphit.compile_and_load("pagerank.gt", linker_args=["-lm"], parallelization_type=graphit.PARALLEL_CILK)
</code></pre></div></div>

<p>In this example we provide the <code class="highlighter-rouge">parallelization_type</code> as <code class="highlighter-rouge">PARALLEL_CILK</code>. This instructs the GraphIt compiler to make use of the CILK runtime while compiling the module. If we had used the graphit.PARALLEL_NONE option (which is the default option), the compiled code would have ran serially.</p>


      </section>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/prism.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-79370201-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
