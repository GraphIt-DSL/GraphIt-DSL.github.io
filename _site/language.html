<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>The GraphIt Programming Language</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="stylesheets/prism.css" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40269412-1']);
      _gaq.push(['_setDomainName', 'simit-lang.org']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index"><h1 class="title"> GraphIt</h1></a>
        <p>A high-performance graph domain specific language</p>
        <ul>
          <li><a href="http://github.com/yunmingzhang17/graphit">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="getting-started">Getting Started</a></p>
        <p><a href="language">Language Manual</a></p>
        <p><a href="publications">Publications</a></p>
	<p><a href="user-group">User Group</a></p>
      </header>
      <footer>
        <p><a href="https://yunmingzhang.wordpress.com/">Yunming Zhang</a> <br>yunming at mit dot edu</p>
        <p><small>Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
      <section class="language-graphit">
      <h1 class="no_toc" id="the-graphit-programming-language">The GraphIt Programming Language</h1>

<p>This guide introduces GraphIt language features and shows how they can be used in
programs.</p>

<ul id="markdown-toc">
  <li><a href="#basics" id="markdown-toc-basics">Basics</a>    <ul>
      <li><a href="#functions" id="markdown-toc-functions">Functions</a></li>
      <li><a href="#variables" id="markdown-toc-variables">Variables</a></li>
      <li><a href="#comments" id="markdown-toc-comments">Comments</a></li>
    </ul>
  </li>
  <li><a href="#control-flow-statements" id="markdown-toc-control-flow-statements">Control Flow Statements</a>    <ul>
      <li><a href="#if-statements" id="markdown-toc-if-statements">If Statements</a></li>
      <li><a href="#while-loops" id="markdown-toc-while-loops">While Loops</a></li>
      <li><a href="#for-loops" id="markdown-toc-for-loops">For Loops</a></li>
    </ul>
  </li>
  <li><a href="#elements-vertexsets-edgesets-vectors" id="markdown-toc-elements-vertexsets-edgesets-vectors">Elements, VertexSets, EdgeSets, Vectors</a>    <ul>
      <li><a href="#elements" id="markdown-toc-elements">Elements</a></li>
      <li><a href="#sets" id="markdown-toc-sets">Sets</a></li>
      <li><a href="#edge-sets" id="markdown-toc-edge-sets">Edge Sets</a></li>
    </ul>
  </li>
  <li><a href="#vertexset-operators" id="markdown-toc-vertexset-operators">VertexSet Operators</a></li>
  <li><a href="#edgeset-operators" id="markdown-toc-edgeset-operators">EdgeSet Operators</a></li>
</ul>

<h1 id="basics">Basics</h1>
<p>GraphIt is an imperative language with statements, control flow, and high-level operators on sts of vertices ane edges. In this section, we describe some of the language’s basic constructs.</p>

<h2 id="functions">Functions</h2>
<p>Functions can take any number of parameters, including none. Each parameter
must be declared with its name followed by its type (separated by a <code class="highlighter-rouge">:</code>). In
the following example, the function <code class="highlighter-rouge">add</code> takes two parameters named <code class="highlighter-rouge">a</code> and
<code class="highlighter-rouge">b</code>, both of which are of type <code class="highlighter-rouge">float</code>, and returns a single result (named <code class="highlighter-rouge">c</code>)
that is also a <code class="highlighter-rouge">float</code>. The function result is separated from the list of
parameters by a <code class="highlighter-rouge">-&gt;</code> and the function declaration is delimited by the <code class="highlighter-rouge">end</code>
keyword.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func add(a : float, b : float) -&gt; c : float
  c = a + b;
end
</code></pre></div></div>

<p>Like functions in MATLAB, GraphIt functions can return any number of results,
including none. In the next example, the function <code class="highlighter-rouge">minMax</code> takes two <code class="highlighter-rouge">float</code>
parameters and return two <code class="highlighter-rouge">float</code> results: the smaller of the two inputs as the
first result and the larger of the two inputs as the second result.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func minMax(a : float, b : float) 
    -&gt; (c : float, d : float)
  if a &lt; b
    c = a;
    d = b;
  else
    c = b;
    d = a;
  end
end
</code></pre></div></div>

<p>Note that the list of function results must be surrounded by parentheses if the
function returns more than one result. (The parentheses are optional if the
function returns just a single result.)</p>

<h2 id="variables">Variables</h2>
<p>Variables are declared in function bodies or in the global scope using the
<code class="highlighter-rouge">var</code> keyword. The following example declares an integer variable named <code class="highlighter-rouge">foo</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : int;
</code></pre></div></div>

<p>If the variable declaration has an initializer, then the variable’s type can be
inferred from the initializer value. The following are equivalent ways to
define a floating-point variable that is initialized to <code class="highlighter-rouge">0.0</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : float = 0.0;
var foo = 0.0;
</code></pre></div></div>

<p>The <code class="highlighter-rouge">const</code> keyword creates a variable that cannot be modified after
initialization.  The following example shows three ways to declare constant
variables that are initialized to <code class="highlighter-rouge">0.0</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const foo = 0.0;
const bar = foo;
bazz = 0.0;
</code></pre></div></div>

<p>Individual elements of const vectors can still be updated.</p>

<h2 id="comments">Comments</h2>
<p>Single-line comments start with <code class="highlighter-rouge">%</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h = 0.01;  % h is the time-step size.
</code></pre></div></div>

<p>Multi-line comments are surrounded by <code class="highlighter-rouge">%{</code> and <code class="highlighter-rouge">%}</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%{
h is the time-step size.
h is initialized to one millisecond.
%}
h = 0.001;
</code></pre></div></div>

<h1 id="control-flow-statements">Control Flow Statements</h1>
<p>GraphIt supports a variety of control flow constructs, including <code class="highlighter-rouge">if</code> statements,
<code class="highlighter-rouge">while</code> loops, <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">while</code> loops and <code class="highlighter-rouge">for</code> loops.</p>

<h2 id="if-statements">If Statements</h2>

<p>In GraphIt, a simple <code class="highlighter-rouge">if</code> statement looks something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
end
</code></pre></div></div>

<p>An <code class="highlighter-rouge">if</code> statement can optionally include an <code class="highlighter-rouge">else</code> clause as well as an any
number of <code class="highlighter-rouge">elif</code> (else-if) clauses:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
elif x &gt; 5
  print "x is greater than 5";
else
  print "x is between 1 and 5";
end
</code></pre></div></div>

<h2 id="while-loops">While Loops</h2>

<p>A <code class="highlighter-rouge">while</code> loop in GraphIt looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while x &lt; 100
  x = 2 * x;
end
</code></pre></div></div>

<p>As with <code class="highlighter-rouge">if</code> statements, logical operators and comparison operators can be used
to construct more complex conditions. Note that if the condition of a <code class="highlighter-rouge">while</code>
loop is false when a GraphIt program first encounters the loop, the loop body
will not be executed at all.</p>

<h2 id="for-loops">For Loops</h2>

<p>GraphIt <code class="highlighter-rouge">for</code> loops are more like those found in MATLAB, Julia and Python than
those available in C. You can use a <code class="highlighter-rouge">for</code> loop to iterate over the set of all integers between two values, as shown in the following example.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in 0:10
  print i;
end
</code></pre></div></div>

<p>Note that the lower bound is <em>inclusive</em> while the upper bound is <em>exclusive</em>
(like Python), so the above example prints all integers between 0 and 9 but
omits 10.</p>

<h1 id="elements-vertexsets-edgesets-vectors">Elements, VertexSets, EdgeSets, Vectors</h1>
<p>Elements, vertexsets, edgesets and vectors form GraphIt’s <em>data model</em>.</p>

<h2 id="elements">Elements</h2>
<p>An element is a type that stores one or more data fields, much like a struct in
C/C++. For example, an element representing a point may store a position vector
<code class="highlighter-rouge">x</code> and a velocity vector <code class="highlighter-rouge">v</code>, while an element represent a spring may store a
scalar mass:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Point
  x : vector[3](float);
  v : vector[3](float);
end

element Element
  m : float;
  l : float;
end
</code></pre></div></div>

<p>To read from or write to a field of an Element <code class="highlighter-rouge">e</code> or a Point <code class="highlighter-rouge">p</code>, you use the
<code class="highlighter-rouge">.</code> operator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e.m = 2.0;
print e.m;  % 2.0

p.x = [0.0, 0.0, 1.0]';
print p.x;  % [0.0, 0.0, 1.0]'
</code></pre></div></div>

<h2 id="sets">Sets</h2>
<p>Unlike C structs, elements live in sets. So Point elements must be stored in
some set, such as <code class="highlighter-rouge">points</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern points : set{Point};
</code></pre></div></div>

<p>The <code class="highlighter-rouge">extern</code> keyword simply means that the <code class="highlighter-rouge">points</code> set comes from outside the
GraphIt program. Typically they have been assembled using the <a href="api">GraphIt
C++API</a>.</p>

<p>The best ways to work with sets are to
<a href="#apply-stencil-update-functions">apply stencil update functions</a> and to
<a href="#assemble-system-vectors-and-matrices">assemble system vectors or matrices</a>.</p>

<h2 id="edge-sets">Edge Sets</h2>
<p>Edge sets are sets that also have connectivity information. In particular, edge
set definitions specify the list of sets from which each edge’s endpoints come.
The following declares a set of spring elements that each connect two points
from the <code class="highlighter-rouge">points</code> set:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern springs : set{Element}(points,points);
</code></pre></div></div>

<p>There is no explicit graph type in GraphIt; rather, graphs are formed implicitly
from the combination of sets and edge sets. This is similar to how graphs are
often defined in mathematical papers (i.e. as an ordered pair <code class="highlighter-rouge">G = (V,E)</code>).</p>

<p>GraphIt’s graphs are hypergraphs, which just means that edges can have more (or
less) than two endpoints. More precisely, a GraphIt graph is a <em>k</em>-uniform
hypergraphs; in other words, each edge can (and must) connect <em>k</em> vertices,
where <em>k</em> is some non-negative integer constant. Thus, we can declare
additional edge sets that contain triangle, tetrahedral or even hexahedral
elements, as demonstrated below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern triangles  : set{Element}(points,points,points);
extern tetrahedra : set{Element}(points * 4);
extern hexahedra  : set{Element}(points * 6);
</code></pre></div></div>

<p>The <code class="highlighter-rouge">tetrahedra</code> and <code class="highlighter-rouge">hexahedra</code> sets are <em>homogeneous</em> edge sets. This means
that all of their endpoints are elements from the same set. Because of this we
could use a syntactic shortcut to declare their endpoint lists, which freed us
from writing out <code class="highlighter-rouge">point</code> four or six times.  The two ways to declare
homogeneous edge sets shown above are equivalent.</p>

<p>That said, the more verbose syntax also lets us declare <em>heterogeneous</em> edge
sets, which are edge sets that can connect two or more <em>different</em> sets. For
instance, the <code class="highlighter-rouge">links</code> edge set below connects a set of triangles to a set of
tetrahedra.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern links : set{Link}(triangles, tetrahedra);
</code></pre></div></div>

<h1 id="vertexset-operators">VertexSet Operators</h1>

<h1 id="edgeset-operators">EdgeSet Operators</h1>

<p>A stencil update function is any function that takes as arguments an element
and (if the element is an edge) its endpoints. A stencil update function that
writes to the input element is called a <em>gather</em> (or <em>pull</em>) stencil, while a
stencil update function that writes to the endpoints is called a <em>scatter</em> (or
<em>pull</em>) stencil. The following stencil function moves a point one unit in the x
direction. The <code class="highlighter-rouge">inout</code> keyword declares that <code class="highlighter-rouge">p</code> can be written to.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func move(inout p : Point)
  p.x(0) = p.x(0) + 1.0;
end
</code></pre></div></div>

<p>Stencil update functions are applied to every element of a set concurrently
using an <code class="highlighter-rouge">apply</code> statement. The following statement moves every point in the
<code class="highlighter-rouge">points</code> set one unit in the x direction:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply move to points;
</code></pre></div></div>

<p>Since <code class="highlighter-rouge">move</code> only takes a single point as input, the stencil can access just
that one point and therefore has a completely local effect.</p>

<p>A stencil update function that takes an edge from an edge set as input can
access the element as well as the endpoints corresponding to that edge. As an
example, the following stencil takes a spring, computes its length and stores
the length into the <code class="highlighter-rouge">l</code> field of the corresponding element:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func length(inout s : Element,  p : (src : Point, dst : Point))
  s.l = norm(p.dst.x - p.src.x);
end
</code></pre></div></div>

<p>In the function definition above, <code class="highlighter-rouge">p</code> is a tuple containing the two endpoints
of the spring. To be more precise, <code class="highlighter-rouge">p</code> is a <em>named</em> (or <em>heterogeneous</em>) tuple,
meaning its elements can be accessed by name using the <code class="highlighter-rouge">.</code> operator. Note that
since all elements of <code class="highlighter-rouge">p</code> are actually of the same element type, we could have
instead declared <code class="highlighter-rouge">p</code> as an <em>unnamed</em> (or <em>homogeneous</em>) tuple that is indexed
by integral indices using parentheses, as the following equivalent definition
of <code class="highlighter-rouge">length</code> demonstrates:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func length(inout s : Element, p : (Point*2))
  s.l = norm(p(1).x - p(0).x);
end
</code></pre></div></div>

<p>Now to update the lengths of all spring elements in the <code class="highlighter-rouge">springs</code> set, we again
use an apply statement:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply length to springs;
</code></pre></div></div>


      </section>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/prism.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-79370201-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
